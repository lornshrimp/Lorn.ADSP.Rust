# 广告投放引擎数据访问层技术设计（Rust 实现版本）

## 设计概述

广告投放引擎数据访问层是基于系统统一基础设施的业务特化层，专门为广告投放引擎提供高性能数据访问能力。本设计**严格遵循"不重复造轮子"原则**，直接使用已有的数据访问基础设施、配置管理和依赖注入组件，只实现广告投放业务特有的数据提供者。

### 核心设计原则

**基础设施复用原则**：
- **完全基于统一数据访问层**：使用 `lorn_adsp_infrastructure::data_access::core` 的 `BusinessDataProviderBase` trait
- **完全基于统一配置管理**：使用 `lorn_adsp_infrastructure::configuration` 的配置基础设施  
- **完全基于统一依赖注入**：使用 `lorn_adsp_infrastructure::dependency_injection` 的组件发现机制
- **完全基于领域模型设计**：使用 `lorn_adsp_core::domain` 中定义的所有实体和值对象

**业务特化原则**：
- **单一职责**：数据提供者仅负责纯数据访问，不包含任何业务逻辑
- **领域专用**：针对广告投放业务场景的数据访问优化
- **性能优先**：支持实时竞价场景的毫秒级响应要求
- **缓存优先**：基于广告业务特点的缓存策略优化

### 架构位置和依赖关系

```mermaid
graph TD
    subgraph "现有基础设施（引用使用）"
        A[数据访问层技术设计] --> A1[BusinessDataProviderBase trait]
        A --> A2[DataAccessRouter trait]
        A --> A3[Repository<T> trait]
        
        B[统一配置基础设施] --> B1[配置管理]
        B --> B2[配置验证]
        B --> B3[热重载]
        
        C[统一依赖注入] --> C1[组件发现]
        C --> C2[自动注册]
        C --> C3[生命周期管理]
        
        D[领域模型设计] --> D1[实体定义]
        D --> D2[值对象定义]
        D --> D3[聚合根设计]
    end
    
    subgraph "广告引擎数据访问层（本设计范围）"
        E[业务数据提供者] --> E1[AdCandidateDataProvider]
        E --> E2[UserProfileDataProvider]
        E --> E3[TargetingConfigDataProvider]
        
        F[业务特化接口] --> F1[AdCandidateDataProvider trait]
        F --> F2[UserProfileDataProvider trait]
        F --> F3[TargetingConfigDataProvider trait]
        
        G[广告引擎专用配置] --> G1[缓存策略配置]
        G --> G2[性能指标配置]
        G --> G3[路由优化配置]
    end
    
    E1 --> A1
    E2 --> A1
    E3 --> A1
    
    E --> B
    E --> C
    E --> D
    
    style A fill:#e8f5e8
    style B fill:#e8f5e8  
    style C fill:#e8f5e8
    style D fill:#e8f5e8
    style E fill:#fff3e0
    style F fill:#fff3e0
    style G fill:#fff3e0
```
## 1. 项目结构和依赖关系

### 1.1 Cargo 工作空间中的包位置

广告投放引擎数据访问层**不创建新的基础设施包**，而是基于现有包实现业务特化：

```text
Cargo.toml (workspace)
├── crates/
│   ├── core/                                          # 核心业务层
│   │   ├── domain/                                    # 【引用】领域模型（已存在）
│   │   │   ├── src/
│   │   │   │   ├── entities/                          # 【引用】所有领域实体
│   │   │   │   ├── value_objects/                     # 【引用】所有值对象
│   │   │   │   └── aggregates/                        # 【引用】所有聚合根
│   │   │   └── Cargo.toml
│   │   │
│   │   └── ad_engine_abstractions/                    # 【新建】广告引擎抽象接口
│   │       ├── src/
│   │       │   ├── traits/                            # 广告引擎特化 trait 定义
│   │       │   │   ├── ad_candidate_data_provider.rs   # 广告候选数据提供者 trait
│   │       │   │   ├── user_profile_data_provider.rs   # 用户画像数据提供者 trait
│   │       │   │   └── targeting_config_data_provider.rs # 定向配置数据提供者 trait
│   │       │   ├── models/                            # 请求响应模型
│   │       │   │   ├── ad_candidate_request.rs        # 广告候选查询请求
│   │       │   │   ├── user_profile_request.rs        # 用户画像查询请求
│   │       │   │   └── targeting_config_request.rs    # 定向配置查询请求
│   │       │   ├── enums/                             # 广告引擎专用枚举
│   │       │   │   ├── ad_engine_domain.rs           # 广告引擎领域枚举
│   │       │   │   └── ad_engine_operation.rs        # 广告引擎操作枚举
│   │       │   └── lib.rs
│   │       └── Cargo.toml
│   │
│   ├── infrastructure/                                # 基础设施层
│   │   ├── data_access/                               # 【引用】统一数据访问基础设施（已存在）
│   │   ├── configuration/                             # 【引用】统一配置基础设施（已存在）
│   │   ├── dependency_injection/                      # 【引用】统一依赖注入基础设施（已存在）
│   │   │
│   │   └── ad_engine_data_access/                     # 【新建】广告引擎数据访问实现
│   │       ├── src/
│   │       │   ├── providers/                         # 业务数据提供者实现
│   │       │   │   ├── ad_candidate_data_provider.rs  # 实现 BusinessDataProviderBase
│   │       │   │   ├── user_profile_data_provider.rs  # 实现 BusinessDataProviderBase
│   │       │   │   └── targeting_config_data_provider.rs # 实现 BusinessDataProviderBase
│   │       │   ├── configuration/                     # 广告引擎专用配置选项
│   │       │   │   └── ad_engine_data_access_options.rs # 使用统一配置基础设施
│   │       │   ├── extensions/                        # 服务注册扩展
│   │       │   │   └── service_collection_extensions.rs # 使用统一依赖注入基础设施
│   │       │   └── lib.rs
│   │       └── Cargo.toml
│   │
│   └── services/                                      # 服务层
│       └── ad_engine/                                 # 【引用】广告引擎服务（已存在）
│           ├── src/
│           └── Cargo.toml
```

### 1.2 包依赖关系

```mermaid
graph TD
    A[core-ad-engine-abstractions] --> B[infrastructure-data-access-abstractions]
    A --> C[core-domain]
    
    D[infrastructure-ad-engine-data-access] --> A
    D --> E[infrastructure-data-access-core]
    D --> F[infrastructure-configuration]
    D --> G[infrastructure-dependency-injection]
    
    H[services-ad-engine] --> A
    H --> D
    
    style A fill:#e1f5fe,color:#000
    style D fill:#f3e5f5,color:#000
    style H fill:#e8f5e8,color:#000
```

**依赖关系说明**：

- **抽象层**：仅依赖基础设施抽象和领域模型，不依赖具体实现
- **实现层**：依赖抽象层和基础设施核心组件，实现 BusinessDataProviderBase trait
- **服务层**：通过抽象 trait 使用数据访问能力，不直接依赖实现

### 1.3 基础设施引用说明

**引用的基础设施组件**：

| 基础设施组件               | 引用方式   | 使用场景                     |
| -------------------------- | ---------- | ---------------------------- |
| `BusinessDataProviderBase` | trait 实现 | 所有数据提供者的基础 trait   |
| `DataAccessRouter`         | 依赖注入   | 自动路由到缓存或数据库       |
| `Repository<T>`            | 自动注入   | 基础实现内部访问数据库       |
| `AdEngineCacheProvider`    | 自动注入   | 基础实现内部管理缓存         |
| 统一配置基础设施           | 配置约定   | 自动绑定配置选项             |
| 统一依赖注入基础设施       | 过程宏标记 | 自动发现和注册组件           |
| 领域实体和值对象           | 直接引用   | 作为数据提供者的输入输出类型 |

**不重复实现的组件**：

- ❌ 缓存管理器（使用统一数据访问层的缓存基础设施）
- ❌ 数据库连接池（使用统一数据访问层的连接管理）
- ❌ 配置管理器（使用统一配置基础设施）
- ❌ 健康检查器（使用统一基础设施的健康检查）
- ❌ 监控指标（使用统一基础设施的监控组件）

## 2. 广告引擎特化接口设计

基于现有的 `DataAccessProvider` 基础 trait，广告投放引擎定义业务特化的数据提供者 trait。这些 trait 专注于广告投放业务场景的数据访问需求。

### 2.1 核心业务 trait

**位置**：`crates/core/ad_engine_abstractions/src/traits/`

```rust
use async_trait::async_trait;
use std::collections::HashMap;
use tokio_postgres::CancellationToken;
use lorn_adsp_core::domain::entities::*;
use lorn_adsp_infrastructure::data_access::DataAccessProvider;

/// 广告候选数据提供者 trait
/// 职责：提供广告候选相关的纯数据访问操作
/// 基于数据模型分层设计中标记为"需要存储"的实体
#[async_trait]
pub trait AdCandidateDataProvider: DataAccessProvider {
    /// 根据广告位ID获取活跃的广告活动列表
    /// 注意：只返回数据库中的原始记录，不进行业务逻辑过滤
    async fn get_active_campaigns_by_placement(
        &self,
        placement_id: &str,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<Campaign>, Box<dyn std::error::Error + Send + Sync>>;

    /// 批量获取广告创意信息
    async fn get_creatives_by_campaign_ids(
        &self,
        campaign_ids: &[uuid::Uuid],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<uuid::Uuid, Vec<Creative>>, Box<dyn std::error::Error + Send + Sync>>;

    /// 批量获取广告位配置信息
    async fn get_ad_slot_configurations_batch(
        &self,
        placement_ids: &[String],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<String, AdSlotConfiguration>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取广告主的所有广告
    async fn get_advertisements_by_advertiser(
        &self,
        advertiser_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<Advertisement>, Box<dyn std::error::Error + Send + Sync>>;
}

/// 用户画像数据提供者 trait
/// 职责：提供用户画像相关的纯数据访问操作
/// 基于数据模型分层设计中的UserProfile及其支持实体
#[async_trait]
pub trait UserProfileDataProvider: DataAccessProvider {
    /// 获取用户基础画像信息（包含人口统计学信息、兴趣、行为、标签）
    async fn get_user_profile(
        &self,
        user_id: &str,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Option<UserProfile>, Box<dyn std::error::Error + Send + Sync>>;

    /// 批量获取用户画像信息
    async fn get_user_profiles_batch(
        &self,
        user_ids: &[String],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<String, UserProfile>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取用户的人口统计学信息
    async fn get_user_demographics(
        &self,
        user_profile_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<UserDemographic>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取用户兴趣信息
    async fn get_user_interests(
        &self,
        user_profile_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<UserInterest>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取用户行为数据
    async fn get_user_behaviors(
        &self,
        user_profile_id: uuid::Uuid,
        from_date: Option<chrono::DateTime<chrono::Utc>>,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<UserBehavior>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取用户标签
    async fn get_user_tags(
        &self,
        user_profile_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<UserTag>, Box<dyn std::error::Error + Send + Sync>>;
}

/// 定向配置数据提供者 trait
/// 职责：提供定向配置相关的纯数据访问操作
/// 基于数据模型分层设计中的TargetingConfig及其支持实体
#[async_trait]
pub trait TargetingConfigDataProvider: DataAccessProvider {
    /// 获取广告活动的定向配置（包含定向条件和动态参数）
    async fn get_targeting_configuration(
        &self,
        campaign_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Option<TargetingConfig>, Box<dyn std::error::Error + Send + Sync>>;

    /// 批量获取定向配置
    async fn get_targeting_configurations_batch(
        &self,
        campaign_ids: &[uuid::Uuid],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<uuid::Uuid, TargetingConfig>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取定向策略模板
    async fn get_targeting_policy(
        &self,
        policy_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Option<TargetingPolicy>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取定向条件
    async fn get_targeting_criteria(
        &self,
        targeting_config_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<TargetingCriteria>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取动态参数
    async fn get_dynamic_parameters(
        &self,
        targeting_config_id: uuid::Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<DynamicParameter>, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取公共定向策略模板列表
    async fn get_public_targeting_policies(
        &self,
        category: Option<&str>,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<TargetingPolicy>, Box<dyn std::error::Error + Send + Sync>>;
}

/// 投放记录数据提供者 trait
/// 职责：提供投放记录相关的纯数据访问操作
/// 基于数据模型分层设计中的DeliveryRecord实体
#[async_trait]
pub trait DeliveryRecordDataProvider: DataAccessProvider {
    /// 记录广告投放
    async fn create_delivery_record(
        &self,
        record: &DeliveryRecord,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<uuid::Uuid, Box<dyn std::error::Error + Send + Sync>>;

    /// 获取广告活动的投放记录
    async fn get_delivery_records_by_campaign(
        &self,
        campaign_id: uuid::Uuid,
        from_date: Option<chrono::DateTime<chrono::Utc>>,
        to_date: Option<chrono::DateTime<chrono::Utc>>,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<DeliveryRecord>, Box<dyn std::error::Error + Send + Sync>>;

    /// 批量获取投放记录
    async fn get_delivery_records_batch(
        &self,
        record_ids: &[uuid::Uuid],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<DeliveryRecord>, Box<dyn std::error::Error + Send + Sync>>;

    /// 更新投放记录状态
    async fn update_delivery_record_status(
        &self,
        record_id: uuid::Uuid,
        status: DeliveryStatus,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
}
```

### 2.2 基础设施依赖说明

**重要**：广告引擎数据访问层完全基于现有基础设施，不重复实现任何架构组件：

| 基础设施组件               | 引用位置                               | 使用方式                             |
| -------------------------- | -------------------------------------- | ------------------------------------ |
| `BusinessDataProviderBase` | `infrastructure::data_access::core`    | 实现 trait，获得完整数据访问能力     |
| `DataAccessRouter`         | `infrastructure::data_access::core`    | 自动注入，处理缓存和数据库路由       |
| `Repository<T>`            | `infrastructure::data_access::core`    | 自动注入，提供数据库访问能力         |
| 统一缓存基础设施           | `infrastructure::data_access::*`       | 基础实现自动处理多级缓存逻辑         |
| 统一配置基础设施           | `infrastructure::configuration`        | 使用配置约定自动绑定配置选项         |
| 统一依赖注入基础设施       | `infrastructure::dependency_injection` | 使用过程宏标记自动发现和注册组件     |
| 领域实体和值对象           | `core::domain::entities`               | 直接引用，作为数据访问的输入输出类型 |

**架构透明性**：

- **缓存策略**：完全由 `DataAccessRouter` 和基础实现处理，业务层无感知
- **路由决策**：统一基础设施根据配置自动选择最优数据源
- **性能监控**：基础实现自动记录所有性能指标和访问统计
- **故障处理**：统一的重试、熔断和降级策略

## 3. 数据提供者实现指导

### 3.1 基于 BusinessDataProviderBase 的实现模式

所有广告引擎数据提供者都必须实现统一数据访问层的 `BusinessDataProviderBase` trait，该 trait 已经处理了：

- **缓存优先逻辑**：自动实现缓存查询→数据库查询→缓存回写的完整流程
- **路由决策处理**：通过 `DataAccessRouter` 自动选择合适的技术提供者
- **异常处理机制**：统一的错误处理、重试和降级策略
- **性能监控**：自动记录性能指标和访问统计

### 3.2 实现样例

**AdCandidateDataProviderImpl 实现样例**：

```rust
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use tokio_postgres::CancellationToken;
use log::{error, info};
use uuid::Uuid;
use sqlx::{PgPool, Row};

use lorn_adsp_infrastructure::{
    data_access::core::{BusinessDataProviderBase, DataAccessContext, DataProviderMetadata, DataProviderType},
    dependency_injection::Component,
};
use lorn_adsp_core::domain::entities::*;
use crate::traits::AdCandidateDataProvider;

#[derive(Component)]
#[component(config_section = "data_providers.ad_candidate")]
pub struct AdCandidateDataProviderImpl {
    pool: Arc<PgPool>,
}

impl AdCandidateDataProviderImpl {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl BusinessDataProviderBase for AdCandidateDataProviderImpl {
    fn create_metadata(&self) -> DataProviderMetadata {
        DataProviderMetadata {
            provider_id: "AdCandidateDataProvider_v1.0".to_string(),
            provider_name: "广告候选数据提供者".to_string(),
            provider_type: DataProviderType::BusinessLogic,
            business_entity: "AdCandidate".to_string(),
            supported_operations: vec!["GetCandidates".to_string(), "BatchQuery".to_string()],
            priority: 100,
        }
    }
}

#[async_trait]
impl AdCandidateDataProvider for AdCandidateDataProviderImpl {
    async fn get_active_campaigns_by_placement(
        &self,
        placement_id: &str,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<Campaign>, Box<dyn std::error::Error + Send + Sync>> {
        let context = DataAccessContext {
            operation_type: "GetActiveCampaignsByPlacement".to_string(),
            entity_type: "Campaign".to_string(),
            parameters: {
                let mut params = HashMap::new();
                params.insert("PlacementId".to_string(), placement_id.to_string());
                params
            },
        };

        // 使用基础实现的数据访问模式：缓存查询→数据库查询→缓存回写
        self.get_async(&context, || async {
            // 仅返回数据库中的原始数据，不进行业务逻辑过滤
            let query = r#"
                SELECT c.*, a.*, bc.*, tc.*
                FROM campaigns c
                INNER JOIN advertisers a ON c.advertiser_id = a.id
                LEFT JOIN budget_constraints bc ON c.id = bc.campaign_id
                LEFT JOIN targeting_configs tc ON c.targeting_config_id = tc.id
                WHERE c.status = 'Active'
                  AND c.start_time <= NOW()
                  AND c.end_time >= NOW()
                  AND c.placement_id = $1
            "#;

            let rows = sqlx::query(query)
                .bind(placement_id)
                .fetch_all(&*self.pool)
                .await?;

            let campaigns: Vec<Campaign> = rows
                .into_iter()
                .map(|row| Campaign::from_row(&row))
                .collect::<Result<Vec<_>, _>>()?;

            Ok(campaigns)
        }).await
    }

    async fn get_creatives_by_campaign_ids(
        &self,
        campaign_ids: &[Uuid],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<Uuid, Vec<Creative>>, Box<dyn std::error::Error + Send + Sync>> {
        let context = DataAccessContext {
            operation_type: "GetCreativesByCampaignIds".to_string(),
            entity_type: "Creative".to_string(),
            parameters: {
                let mut params = HashMap::new();
                params.insert("CampaignIds".to_string(), format!("{:?}", campaign_ids));
                params
            },
        };

        self.get_async(&context, || async {
            let query = r#"
                SELECT c.*, ca.*
                FROM creatives c
                LEFT JOIN creative_assets ca ON c.id = ca.creative_id
                WHERE c.campaign_id = ANY($1)
                  AND c.status = 'Approved'
            "#;

            let campaign_ids_vec: Vec<Uuid> = campaign_ids.to_vec();
            let rows = sqlx::query(query)
                .bind(&campaign_ids_vec)
                .fetch_all(&*self.pool)
                .await?;

            let mut result: HashMap<Uuid, Vec<Creative>> = HashMap::new();
            
            for row in rows {
                let creative = Creative::from_row(&row)?;
                let campaign_id = creative.campaign_id;
                
                result.entry(campaign_id)
                    .or_insert_with(Vec::new)
                    .push(creative);
            }

            Ok(result)
        }).await
    }

    async fn get_ad_slot_configurations_batch(
        &self,
        placement_ids: &[String],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<String, AdSlotConfiguration>, Box<dyn std::error::Error + Send + Sync>> {
        let context = DataAccessContext {
            operation_type: "GetAdSlotConfigurationsBatch".to_string(),
            entity_type: "AdSlotConfiguration".to_string(),
            parameters: {
                let mut params = HashMap::new();
                params.insert("PlacementIds".to_string(), format!("{:?}", placement_ids));
                params
            },
        };

        self.get_async(&context, || async {
            let query = r#"
                SELECT c.*, ss.*, fr.*
                FROM ad_slot_configurations c
                LEFT JOIN size_specifications ss ON c.id = ss.ad_slot_config_id
                LEFT JOIN format_requirements fr ON c.id = fr.ad_slot_config_id
                WHERE c.placement_id = ANY($1)
            "#;

            let placement_ids_vec: Vec<String> = placement_ids.to_vec();
            let rows = sqlx::query(query)
                .bind(&placement_ids_vec)
                .fetch_all(&*self.pool)
                .await?;

            let mut result: HashMap<String, AdSlotConfiguration> = HashMap::new();
            
            for row in rows {
                let config = AdSlotConfiguration::from_row(&row)?;
                result.insert(config.placement_id.clone(), config);
            }

            Ok(result)
        }).await
    }

    async fn get_advertisements_by_advertiser(
        &self,
        advertiser_id: Uuid,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Vec<Advertisement>, Box<dyn std::error::Error + Send + Sync>> {
        let context = DataAccessContext {
            operation_type: "GetAdvertisementsByAdvertiser".to_string(),
            entity_type: "Advertisement".to_string(),
            parameters: {
                let mut params = HashMap::new();
                params.insert("AdvertiserId".to_string(), advertiser_id.to_string());
                params
            },
        };

        self.get_async(&context, || async {
            let query = r#"
                SELECT a.*, c.*, cr.*
                FROM advertisements a
                INNER JOIN campaigns c ON a.id = c.advertisement_id
                LEFT JOIN creatives cr ON a.id = cr.advertisement_id
                WHERE c.advertiser_id = $1
                  AND a.status = 'Active'
            "#;

            let rows = sqlx::query(query)
                .bind(advertiser_id)
                .fetch_all(&*self.pool)
                .await?;

            let advertisements: Vec<Advertisement> = rows
                .into_iter()
                .map(|row| Advertisement::from_row(&row))
                .collect::<Result<Vec<_>, _>>()?;

            Ok(advertisements)
        }).await
    }
}
```

**UserProfileDataProviderImpl 实现样例**：

```rust
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use tokio_postgres::CancellationToken;
use uuid::Uuid;
use sqlx::{PgPool, Row};

use lorn_adsp_infrastructure::{
    data_access::core::{BusinessDataProviderBase, DataAccessContext, DataProviderMetadata, DataProviderType},
    dependency_injection::Component,
};
use lorn_adsp_core::domain::entities::*;
use crate::traits::UserProfileDataProvider;

#[derive(Component)]
#[component(config_section = "data_providers.user_profile")]
pub struct UserProfileDataProviderImpl {
    pool: Arc<PgPool>,
}

impl UserProfileDataProviderImpl {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl BusinessDataProviderBase for UserProfileDataProviderImpl {
    fn create_metadata(&self) -> DataProviderMetadata {
        DataProviderMetadata {
            provider_id: "UserProfileDataProvider_v1.0".to_string(),
            provider_name: "用户画像数据提供者".to_string(),
            provider_type: DataProviderType::BusinessLogic,
            business_entity: "UserProfile".to_string(),
            supported_operations: vec!["GetProfile".to_string(), "BatchQuery".to_string()],
            priority: 90,
        }
    }
}

#[async_trait]
impl UserProfileDataProvider for UserProfileDataProviderImpl {
    async fn get_user_profile(
        &self,
        user_id: &str,
        cancellation_token: Option<CancellationToken>,
    ) -> Result<Option<UserProfile>, Box<dyn std::error::Error + Send + Sync>> {
        let context = DataAccessContext {
            operation_type: "GetUserProfile".to_string(),
            entity_type: "UserProfile".to_string(),
            parameters: {
                let mut params = HashMap::new();
                params.insert("UserId".to_string(), user_id.to_string());
                params
            },
        };

        self.get_async(&context, || async {
            let query = r#"
                SELECT up.*, ud.*, ui.*, ub.*, ut.*
                FROM user_profiles up
                LEFT JOIN user_demographics ud ON up.id = ud.user_profile_id
                LEFT JOIN user_interests ui ON up.id = ui.user_profile_id
                LEFT JOIN user_behaviors ub ON up.id = ub.user_profile_id
                LEFT JOIN user_tags ut ON up.id = ut.user_profile_id
                WHERE up.user_id = $1
            "#;

            let row = sqlx::query(query)
                .bind(user_id)
                .fetch_optional(&*self.pool)
                .await?;

            match row {
                Some(row) => Ok(Some(UserProfile::from_row(&row)?)),
                None => Ok(None),
            }
        }).await
    }

    async fn get_user_profiles_batch(
        &self,
        user_ids: &[String],
        cancellation_token: Option<CancellationToken>,
    ) -> Result<HashMap<String, UserProfile>, Box<dyn std::error::Error + Send + Sync>> {
        let context = DataAccessContext {
            operation_type: "GetUserProfilesBatch".to_string(),
            entity_type: "UserProfile".to_string(),
            parameters: {
                let mut params = HashMap::new();
                params.insert("UserIds".to_string(), format!("{:?}", user_ids));
                params
            },
        };

        self.get_async(&context, || async {
            let query = r#"
                SELECT up.*, ud.*, ui.*, ub.*, ut.*
                FROM user_profiles up
                LEFT JOIN user_demographics ud ON up.id = ud.user_profile_id
                LEFT JOIN user_interests ui ON up.id = ui.user_profile_id
                LEFT JOIN user_behaviors ub ON up.id = ub.user_profile_id
                LEFT JOIN user_tags ut ON up.id = ut.user_profile_id
                WHERE up.user_id = ANY($1)
            "#;

            let user_ids_vec: Vec<String> = user_ids.to_vec();
            let rows = sqlx::query(query)
                .bind(&user_ids_vec)
                .fetch_all(&*self.pool)
                .await?;

            let mut result: HashMap<String, UserProfile> = HashMap::new();
            
            for row in rows {
                let profile = UserProfile::from_row(&row)?;
                result.insert(profile.user_id.clone(), profile);
            }

            Ok(result)
        }).await
    }

    // 其他接口方法实现...
}
```

### 3.3 配置和注册

**配置选项**（使用统一配置基础设施）：

```toml
[data_providers.ad_candidate]
timeout_ms = 5
max_batch_size = 50

[data_providers.ad_candidate.cache_settings]
default_ttl = "5m"
sliding_expiration = true

[data_providers.user_profile]
timeout_ms = 20
max_batch_size = 100

[data_providers.user_profile.cache_settings]
default_ttl = "1h"
sliding_expiration = true

[data_providers.user_profile.privacy_mode]
enabled = true
data_masking = true
auto_expiration = true

[data_providers.targeting_config]
timeout_ms = 30
max_batch_size = 30

[data_providers.targeting_config.cache_settings]
default_ttl = "4h"
sliding_expiration = false

[data_providers.delivery_record]
timeout_ms = 10
max_batch_size = 200

[data_providers.delivery_record.cache_settings]
default_ttl = "30m"
sliding_expiration = true

[database.ad_engine]
url = "postgresql://username:password@localhost/ad_engine"
max_connections = 10
min_connections = 5
acquire_timeout = "30s"
idle_timeout = "600s"
max_lifetime = "1800s"
```

**服务注册**（使用统一依赖注入基础设施）：

```rust
use lorn_adsp_infrastructure::dependency_injection::ServiceCollection;

pub fn add_ad_engine_data_access(services: &mut ServiceCollection, config: &Config) -> Result<(), Box<dyn std::error::Error>> {
    // 数据库连接池注册
    let database_url = config.get_string("database.ad_engine.url")?;
    let pool = PgPoolOptions::new()
        .max_connections(config.get_u32("database.ad_engine.max_connections").unwrap_or(10))
        .min_connections(config.get_u32("database.ad_engine.min_connections").unwrap_or(5))
        .acquire_timeout(Duration::from_secs(config.get_u64("database.ad_engine.acquire_timeout_secs").unwrap_or(30)))
        .idle_timeout(Duration::from_secs(config.get_u64("database.ad_engine.idle_timeout_secs").unwrap_or(600)))
        .max_lifetime(Duration::from_secs(config.get_u64("database.ad_engine.max_lifetime_secs").unwrap_or(1800)))
        .connect(&database_url)
        .await?;

    services.add_singleton(Arc::new(pool));

    // 广告引擎数据提供者注册（基于统一配置约定自动发现和注册）
    services.add_scoped::<dyn AdCandidateDataProvider, AdCandidateDataProviderImpl>();
    services.add_scoped::<dyn UserProfileDataProvider, UserProfileDataProviderImpl>();
    services.add_scoped::<dyn TargetingConfigDataProvider, TargetingConfigDataProviderImpl>();
    services.add_scoped::<dyn DeliveryRecordDataProvider, DeliveryRecordDataProviderImpl>();
    
    // 注册数据访问相关的基础设施服务
    services.add_scoped::<dyn DataAccessRouter, DataAccessRouterImpl>();
    
    Ok(())
}
```
**数据迁移和初始化**：

```rust
use sqlx_migrator::{migrate, Migration};
use log::{info, error};

pub async fn initialize_ad_engine_database(pool: &PgPool) -> Result<(), Box<dyn std::error::Error>> {
    // 应用挂起的迁移
    migrate(pool).await?;
    
    // 数据库种子数据初始化（如果需要）
    seed_default_data(pool).await?;
    
    info!("广告引擎数据库初始化成功");
    Ok(())
}

async fn seed_default_data(pool: &PgPool) -> Result<(), Box<dyn std::error::Error>> {
    // 创建默认的定向策略模板
    let policy_count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM targeting_policies")
        .fetch_one(pool)
        .await?;
        
    if policy_count == 0 {
        let mut transaction = pool.begin().await?;
        
        sqlx::query(r#"
            INSERT INTO targeting_policies (id, name, category, is_public, description, created_at, updated_at, created_by, updated_by)
            VALUES 
                ($1, '基础人口统计学定向', 'Demographics', true, '基于年龄、性别、地理位置的基础定向策略', NOW(), NOW(), 'System', 'System'),
                ($2, '兴趣定向策略', 'Interest', true, '基于用户兴趣和行为的定向策略', NOW(), NOW(), 'System', 'System')
        "#)
        .bind(uuid::Uuid::new_v4())
        .bind(uuid::Uuid::new_v4())
        .execute(&mut *transaction)
        .await?;
        
        transaction.commit().await?;
    }
    
    Ok(())
}
```

### 3.4 职责边界

**✅ 数据提供者应该做的**：

1. **纯数据访问操作**：
   - 基本 CRUD 操作（Create、Read、Update、Delete）
   - 复杂查询操作（Join、聚合、分页等）
   - 批量数据操作

2. **数据格式转换**：
   - 数据库记录 → 领域实体对象
   - 简单的数据类型转换和映射
   - 枚举值和常量的转换

3. **基本数据验证**：
   - 参数非空验证
   - 数据格式验证（如日期格式、ID格式等）
   - 数据完整性约束检查

4. **SQLx 特定操作**：
   - 查询构建和执行
   - 事务管理
   - 查询优化和性能调优

**❌ 数据提供者禁止做的**：

1. **业务逻辑计算**：
   - 定向条件匹配算法
   - 竞价逻辑和价格计算
   - 广告投放决策逻辑
   - 用户画像评分计算

2. **复杂业务过滤**：
   - 基于多个业务规则的数据过滤
   - 动态策略执行
   - 个性化推荐逻辑

3. **手动资源管理**：
   - 手动缓存管理（由基础实现和配置处理）
   - 手动连接池管理
   - 手动事务管理（除非明确需要）
   - 手动路由决策（由基础设施处理）

4. **外部服务调用**：
   - 调用其他微服务
   - 调用第三方API
   - 消息队列操作

### 3.5 SQLx 最佳实践

**查询优化**：

```rust
// ✅ 正确的做法：预加载相关数据
let campaigns = sqlx::query_as!(
    Campaign,
    r#"
    SELECT c.*, a.*, tc.*, tcr.*
    FROM campaigns c
    INNER JOIN advertisers a ON c.advertiser_id = a.id
    LEFT JOIN targeting_configs tc ON c.targeting_config_id = tc.id
    LEFT JOIN targeting_criteria tcr ON tc.id = tcr.targeting_config_id
    WHERE c.status = $1
    "#,
    CampaignStatus::Active as _
)
.fetch_all(pool)
.await?;

// ❌ 错误的做法：N+1 查询问题
let campaigns = sqlx::query_as!(Campaign, "SELECT * FROM campaigns WHERE status = $1", CampaignStatus::Active as _)
    .fetch_all(pool)
    .await?;
// 然后在循环中查询每个 campaign 的 targeting_config（会触发额外查询）
```

**异步操作**：

```rust
// ✅ 正确的做法：使用异步方法
pub async fn get_campaigns(
    &self,
    pool: &PgPool,
    cancellation_token: Option<CancellationToken>,
) -> Result<Vec<Campaign>, sqlx::Error> {
    let campaigns = sqlx::query_as!(
        Campaign,
        "SELECT * FROM campaigns WHERE status = $1",
        CampaignStatus::Active as _
    )
    .fetch_all(pool)
    .await?;
    
    Ok(campaigns)
}

// ❌ 错误的做法：阻塞异步操作
pub fn get_campaigns_blocking(pool: &PgPool) -> Result<Vec<Campaign>, sqlx::Error> {
    // 使用 tokio::task::block_in_place 或者 futures::executor::block_on
    // 这可能导致性能问题和死锁
    futures::executor::block_on(async {
        sqlx::query_as!(Campaign, "SELECT * FROM campaigns")
            .fetch_all(pool)
            .await
    })
}
```

**UUID 主键处理**：

```rust
// ✅ 正确的做法：使用 Uuid 主键查询
pub async fn get_campaign(
    &self,
    campaign_id: Uuid,
    pool: &PgPool,
) -> Result<Option<Campaign>, sqlx::Error> {
    let campaign = sqlx::query_as!(
        Campaign,
        "SELECT * FROM campaigns WHERE id = $1",
        campaign_id
    )
    .fetch_optional(pool)
    .await?;
    
    Ok(campaign)
}

// ✅ 正确的做法：批量 Uuid 查询
pub async fn get_campaigns_batch(
    &self,
    campaign_ids: &[Uuid],
    pool: &PgPool,
) -> Result<Vec<Campaign>, sqlx::Error> {
    let campaigns = sqlx::query_as!(
        Campaign,
        "SELECT * FROM campaigns WHERE id = ANY($1)",
        campaign_ids
    )
    .fetch_all(pool)
    .await?;
    
    Ok(campaigns)
}
```

### 3.6 实现要点总结

**基于 BusinessDataProviderBase trait 的关键实现要点**：

1. **结构体模式**：实现 trait，注入数据库连接池和其他依赖
2. **元数据实现**：必须实现 `create_metadata()` 方法提供提供者信息
3. **业务方法实现**：构建 `DataAccessContext`，调用基础 trait 的 `get_async()` 方法
4. **职责边界**：只负责数据访问，不实现业务逻辑
5. **基础设施透明**：基础实现自动处理缓存、路由、错误处理等

### 3.7 SQLx 数据库迁移配置

**重要说明**：基于数据模型分层设计文档中的最新标记，广告引擎数据访问层需要为需要持久化存储的实体配置相应的数据库表结构和 SQLx 映射。

#### 3.7.1 数据库模式设计

**位置**：`migrations/`

```sql
-- 001_create_core_entities.sql
-- 核心业务实体表（标记为✅需要存储）

-- 广告表
CREATE TABLE advertisements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    type INTEGER NOT NULL,
    status INTEGER NOT NULL,
    advertiser_id UUID NOT NULL,
    audit_info_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100),
    updated_by VARCHAR(100),
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- 广告活动表
CREATE TABLE campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    description TEXT,
    status INTEGER NOT NULL,
    start_date TIMESTAMPTZ NOT NULL,
    end_date TIMESTAMPTZ NOT NULL,
    advertisement_id UUID NOT NULL,
    advertiser_id UUID NOT NULL,
    targeting_config_id UUID,
    delivery_policy_id UUID,
    budget_info_id UUID,
    bidding_strategy_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100),
    updated_by VARCHAR(100),
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
    FOREIGN KEY (advertisement_id) REFERENCES advertisements(id),
    FOREIGN KEY (advertiser_id) REFERENCES advertisers(id)
);

-- 用户画像表
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id VARCHAR(100) NOT NULL UNIQUE,
    segment_id VARCHAR(100),
    data_source VARCHAR(100),
    status INTEGER NOT NULL,
    last_update_time TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100),
    updated_by VARCHAR(100),
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- 定向配置表
CREATE TABLE targeting_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_id VARCHAR(100) NOT NULL,
    weight DECIMAL(5,4),
    created_from VARCHAR(200),
    source_policy_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100),
    updated_by VARCHAR(100),
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- 其他核心实体表...

-- 外键约束和级联删除规则
ALTER TABLE user_interests 
    ADD CONSTRAINT fk_user_interests_user_profile 
    FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) 
    ON DELETE CASCADE;

ALTER TABLE user_behaviors 
    ADD CONSTRAINT fk_user_behaviors_user_profile 
    FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) 
    ON DELETE CASCADE;

ALTER TABLE user_tags 
    ADD CONSTRAINT fk_user_tags_user_profile 
    FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) 
    ON DELETE CASCADE;

-- 创建唯一索引
CREATE UNIQUE INDEX idx_user_profiles_user_id ON user_profiles(user_id);

-- TargetingConfig 表创建
CREATE TABLE targeting_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_id VARCHAR(100) NOT NULL,
    weight DECIMAL(5,4),
    created_from VARCHAR(200),
    source_policy_id UUID,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 定向配置关联关系
ALTER TABLE targeting_configs 
    ADD CONSTRAINT fk_targeting_configs_source_policy 
    FOREIGN KEY (source_policy_id) REFERENCES targeting_policies(id) 
    ON DELETE RESTRICT;

ALTER TABLE targeting_criteria 
    ADD CONSTRAINT fk_targeting_criteria_config 
    FOREIGN KEY (targeting_config_id) REFERENCES targeting_configs(id) 
    ON DELETE CASCADE;

ALTER TABLE dynamic_parameters 
    ADD CONSTRAINT fk_dynamic_parameters_config 
    FOREIGN KEY (targeting_config_id) REFERENCES targeting_configs(id) 
    ON DELETE CASCADE;

        // 其他核心实体配置...
    }
    
    /// 配置值对象表结构
    ///
    /// 为Rust实现定义SQLx数据库模式
    async fn configure_value_objects(&self) -> Result<(), DatabaseError> {
        // AuditInfo 表创建
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS audit_infos (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                status INTEGER NOT NULL,
                reviewer_comment VARCHAR(1000),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            )
        "#).execute(&self.pool).await?;
        
        // BudgetInfo 表创建
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS budget_infos (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                total_budget DECIMAL(18,4) NOT NULL,
                daily_budget DECIMAL(18,4),
                spent_amount DECIMAL(18,4) DEFAULT 0,
                remaining_budget DECIMAL(18,4),
                budget_type INTEGER NOT NULL,
                created_at TIMESTAMPTZ DEFAULT NOW(),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            )
        "#).execute(&self.pool).await?;
        
        Ok(())
    }
    
    /// 配置支持实体（用于替代复杂类型）
    async fn configure_support_entities(&self) -> Result<(), DatabaseError> {
        // UserDemographic 表配置
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS user_demographics (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                user_profile_id UUID NOT NULL,
                property_name VARCHAR(100) NOT NULL,
                property_value VARCHAR(500),
                data_type VARCHAR(50),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) ON DELETE CASCADE
            )
        "#).execute(&self.pool).await?;
        
        // 创建唯一索引
        sqlx::query("CREATE UNIQUE INDEX IF NOT EXISTS idx_user_demographics_profile_property ON user_demographics(user_profile_id, property_name)")
            .execute(&self.pool).await?;
        
        // UserInterest 表配置
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS user_interests (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                user_profile_id UUID NOT NULL,
                category VARCHAR(100) NOT NULL,
                score DECIMAL(5,4),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) ON DELETE CASCADE
            )
        "#).execute(&self.pool).await?;
        
        sqlx::query("CREATE UNIQUE INDEX IF NOT EXISTS idx_user_interests_profile_category ON user_interests(user_profile_id, category)")
            .execute(&self.pool).await?;
        
        // UserBehavior 表配置
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS user_behaviors (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                user_profile_id UUID NOT NULL,
                behavior_type VARCHAR(100) NOT NULL,
                behavior_value VARCHAR(500),
                occurred_at TIMESTAMPTZ NOT NULL,
                created_at TIMESTAMPTZ DEFAULT NOW(),
                FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) ON DELETE CASCADE
            )
        "#).execute(&self.pool).await?;
        
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_user_behaviors_profile_type_time ON user_behaviors(user_profile_id, behavior_type, occurred_at)")
            .execute(&self.pool).await?;
        
        // UserTag 表配置
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS user_tags (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                user_profile_id UUID NOT NULL,
                tag_name VARCHAR(100) NOT NULL,
                tag_source VARCHAR(100),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                FOREIGN KEY (user_profile_id) REFERENCES user_profiles(id) ON DELETE CASCADE
            )
        "#).execute(&self.pool).await?;
        
        sqlx::query("CREATE UNIQUE INDEX IF NOT EXISTS idx_user_tags_profile_name ON user_tags(user_profile_id, tag_name)")
            .execute(&self.pool).await?;
        
        // TargetingCriteria 表配置
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS targeting_criteria (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                targeting_config_id UUID NOT NULL,
                criteria_type VARCHAR(100) NOT NULL,
                criteria_config TEXT, -- JSON 存储
                weight DECIMAL(5,4),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                FOREIGN KEY (targeting_config_id) REFERENCES targeting_configs(id) ON DELETE CASCADE
            )
        "#).execute(&self.pool).await?;
        
        // DynamicParameter 表配置
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS dynamic_parameters (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                targeting_config_id UUID NOT NULL,
                parameter_name VARCHAR(100) NOT NULL,
                parameter_value VARCHAR(500),
                parameter_type VARCHAR(50),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                FOREIGN KEY (targeting_config_id) REFERENCES targeting_configs(id) ON DELETE CASCADE
            )
        "#).execute(&self.pool).await?;
        
        sqlx::query("CREATE UNIQUE INDEX IF NOT EXISTS idx_dynamic_parameters_config_name ON dynamic_parameters(targeting_config_id, parameter_name)")
            .execute(&self.pool).await?;
        
        Ok(())
    }
    
    /// 配置数据库索引以优化查询性能
    async fn configure_indexes(&self) -> Result<(), DatabaseError> {
        // 性能优化索引
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_campaigns_status_date_range ON campaigns(status, start_date, end_date)")
            .execute(&self.pool).await?;
            
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_delivery_records_campaign_date ON delivery_records(campaign_id, delivered_at)")
            .execute(&self.pool).await?;
            
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_user_profiles_segment_last_update ON user_profiles(segment_id, last_update_time)")
            .execute(&self.pool).await?;
        
        // 业务查询优化索引
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_advertisements_status_type ON advertisements(status, ad_type)")
            .execute(&self.pool).await?;
            
        Ok(())
    }
    
    /// 配置枚举映射
    /// 
    /// 在Rust中，枚举类型通常映射为整数或字符串存储
    fn configure_enum_mappings() -> HashMap<&'static str, EnumMapping> {
        let mut mappings = HashMap::new();
        
        // Advertisement 枚举映射
        mappings.insert("advertisement_type", EnumMapping::Integer);
        mappings.insert("advertisement_status", EnumMapping::Integer);
        
        // Campaign 枚举映射
        mappings.insert("campaign_status", EnumMapping::Integer);
        
        // Advertiser 枚举映射
        mappings.insert("advertiser_status", EnumMapping::Integer);
        
        // MediaResource 枚举映射
        mappings.insert("media_resource_type", EnumMapping::Integer);
        mappings.insert("media_resource_status", EnumMapping::Integer);
        
        // DeliveryRecord 枚举映射
        mappings.insert("delivery_record_status", EnumMapping::Integer);
        
        // UserProfile 枚举映射
        mappings.insert("user_profile_status", EnumMapping::Integer);
        
        mappings
    }
    
}

/// 枚举映射类型定义
#[derive(Debug, Clone)]
enum EnumMapping {
    Integer,
    String,
}

/// 在Rust中，我们不需要排除计算方法，因为struct只包含数据字段
/// 所有的业务逻辑方法都在impl块中实现，不会影响数据库映射
/// 
/// 以下是各个实体的业务方法实现示例：
/// 
/// impl Campaign {
///     pub fn check_budget_availability(&self) -> bool { ... }
///     pub fn get_daily_spend(&self) -> Decimal { ... }
/// }
/// 
/// impl MediaResource {
///     pub fn get_available_inventory(&self) -> i32 { ... }
/// }
/// 
/// impl DeliveryRecord {
///     pub fn calculate_cost(&self) -> Decimal { ... }
///     pub fn generate_report(&self) -> DeliveryReport { ... }
/// }
/// 
/// impl UserProfile {
///     pub fn get_user_segments(&self) -> Vec<UserSegment> { ... }
///     pub fn has_tag(&self, tag_name: &str) -> bool { ... }
///     pub fn get_interest_score(&self, category: &str) -> Option<Decimal> { ... }
///     pub fn get_behavior_pattern(&self) -> BehaviorPattern { ... }
///     pub fn is_target_audience(&self, criteria: &TargetingCriteria) -> bool { ... }
/// }
/// 
/// impl TargetingConfig {
///     pub fn get_criteria(&self) -> &[TargetingCriteria] { ... }
///     pub fn has_criteria(&self, criteria_type: &str) -> bool { ... }
///     pub fn validate_config(&self) -> Result<(), ValidationError> { ... }
///     pub fn clone(&self) -> Self { ... }
/// }
/// 
/// impl TargetingPolicy {
///     pub fn create_config(&self) -> TargetingConfig { ... }
///     pub fn validate(&self) -> Result<(), ValidationError> { ... }
///     pub fn clone(&self) -> Self { ... }
///     pub fn get_criteria_template(&self) -> CriteriaTemplate { ... }
///     pub fn get_usage_statistics(&self) -> UsageStatistics { ... }
/// }

    #endregion
}
```

#### 3.6.2 数据库迁移配置

**Rust SQLx 迁移命令和最佳实践**：

```bash
# 创建新迁移
sqlx migrate add initial_ad_engine_database

# 运行迁移
sqlx migrate run --database-url="postgresql://user:password@localhost/ad_engine_db"

# 回滚迁移
sqlx migrate revert --database-url="postgresql://user:password@localhost/ad_engine_db"

# 生成离线查询检查文件
cargo sqlx prepare --database-url="postgresql://user:password@localhost/ad_engine_db"
```

**种子数据配置**：

```rust
use sqlx::{PgPool, Row};
use uuid::Uuid;
use chrono::Utc;

pub struct AdEngineSeedData;

impl AdEngineSeedData {
    pub async fn seed_data(pool: &PgPool) -> Result<(), sqlx::Error> {
        // 检查是否已有种子数据
        let policy_count = sqlx::query("SELECT COUNT(*) FROM targeting_policies")
            .fetch_one(pool)
            .await?
            .get::<i64, _>(0);
            
        if policy_count == 0 {
            // 种子数据：定向策略模板
            let policy_id = Uuid::new_v4();
            sqlx::query(r#"
                INSERT INTO targeting_policies (
                    id, policy_id, name, description, version, status, 
                    category, is_public, created_at, updated_at, created_by, updated_by
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
            "#)
            .bind(policy_id)
            .bind("DEFAULT_GEO_TARGETING")
            .bind("默认地理定向策略")
            .bind("基于用户地理位置的基础定向策略")
            .bind(1i32)
            .bind(1i32) // PolicyStatus::Published
            .bind("Geographic")
            .bind(true)
            .bind(Utc::now())
            .bind(Utc::now())
            .bind("System")
            .bind("System")
            .execute(pool)
            .await?;
        }
        
        Ok(())
    }
}
```

#### 3.6.3 连接字符串配置

```toml
[database]
url = "postgresql://localhost:5432/ad_engine_db"
max_connections = 20
min_connections = 5
connect_timeout = 30
idle_timeout = 600
max_lifetime = 1800

[ad_engine_data_access]
enable_sensitive_data_logging = false
command_timeout = 30
enable_retry_on_failure = true
max_retry_count = 3
max_retry_delay = "5s"
```

### 3.7 技术数据提供者设计说明

**重要说明**：技术数据提供者（如 Redis 缓存提供者、SQL Server 数据库提供者）的实现应该基于统一数据访问层技术设计中的标准实现，不需要在广告引擎中重复实现。

**技术提供者的职责**：

- **RedisCacheProvider**：实现 `IDataAccessProvider` 接口，提供纯粹的缓存访问能力
- **SqlServerDatabaseProvider**：实现 `IDataAccessProvider` 接口，提供纯粹的数据库访问能力
- **路由决策**：由 `IDataAccessRouter` 根据配置决定使用哪个技术提供者

**架构分层清晰性**：

```mermaid
graph TD
    A[业务层] --> B[业务数据提供者]
    B --> C[IDataAccessRouter]
    C --> D[技术数据提供者]
    
    B1[AdCandidateDataProvider] --> C
    B2[UserProfileDataProvider] --> C
    B3[TargetingConfigDataProvider] --> C
    
    C --> D1[RedisCacheProvider]
    C --> D2[SqlServerDatabaseProvider]
    C --> D3[AlibabaCloudProvider]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    style D fill:#e8f5e8
-- 创建性能优化索引
CREATE INDEX idx_campaign_status_date_range ON campaigns (status, start_date, end_date);
CREATE INDEX idx_delivery_record_campaign_date ON delivery_records (campaign_id, delivered_at);
CREATE INDEX idx_user_profile_segment_last_update ON user_profiles (segment_id, last_update_time);
CREATE INDEX idx_advertisement_status_type ON advertisements (status, type);

-- 注意：以下实体标记为❌临时数据，不创建对应表
-- - AdCandidate (临时处理对象)
-- - AdContext (请求期间临时对象)  
-- - AdRequest (请求期间临时对象)
-- - OverallMatchResult (计算结果临时对象)
-- - MatchResult (计算结果值对象)
-- - MatchConfidence (统计结果值对象)
```

#### 3.7.2 数据库迁移配置

**迁移命令和最佳实践**：

```bash
# 创建新迁移
sqlx migrate add -r create_ad_engine_tables

# 运行迁移
sqlx migrate run --database-url postgresql://user:pass@localhost/ad_engine

# 重置数据库（开发环境）
sqlx migrate revert --database-url postgresql://user:pass@localhost/ad_engine
```

**Cargo.toml 依赖配置**：

```toml
[dependencies]
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono", "json"] }
sqlx-migrator = "0.1"
tokio = { version = "1.0", features = ["full"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
async-trait = "0.1"
```

## 4. 广告引擎专用优化

### 4.1 预测性缓存预热

针对广告投放业务的特殊性，实现预测性缓存预热服务：

```rust
use tokio::time::{Duration, Instant};
use std::collections::HashMap;
use std::sync::Arc;
use log::{info, error};

pub struct PredictiveCacheWarmupService {
    analytics_service: Arc<dyn AnalyticsService>,
    prediction_engine: Arc<dyn PredictionEngine>,
    ad_candidate_provider: Arc<dyn AdCandidateDataProvider>,
    user_profile_provider: Arc<dyn UserProfileDataProvider>,
    targeting_config_provider: Arc<dyn TargetingConfigDataProvider>,
}

impl PredictiveCacheWarmupService {
    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // 1. 分析历史访问模式
        let from_date = chrono::Utc::now() - chrono::Duration::days(7);
        let to_date = chrono::Utc::now();
        
        let access_patterns = self.analytics_service
            .get_access_patterns(from_date, to_date)
            .await?;
        
        // 2. 预测热点数据
        let hot_data_predictions = self.prediction_engine
            .predict_hot_data(&access_patterns)?;
        
        // 3. 预热缓存
        for prediction in hot_data_predictions {
            self.warmup_cache_for_prediction(&prediction).await?;
        }
        
        Ok(())
    }
    
    async fn warmup_cache_for_prediction(
        &self,
        prediction: &HotDataPrediction,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        match prediction.data_type.as_str() {
            "AdCandidate" => {
                self.ad_candidate_provider
                    .warmup_candidate_cache(&prediction.keys)
                    .await?;
            }
            "UserProfile" => {
                self.user_profile_provider
                    .warmup_user_profile_cache(&prediction.keys)
                    .await?;
            }
            "TargetingConfig" => {
                self.targeting_config_provider
                    .warmup_targeting_config_cache(&prediction.keys)
                    .await?;
            }
            _ => {
                error!("未知的数据类型: {}", prediction.data_type);
            }
        }
        
        Ok(())
    }
}

// 支持 trait
#[async_trait]
pub trait AnalyticsService: Send + Sync {
    async fn get_access_patterns(
        &self,
        from: chrono::DateTime<chrono::Utc>,
        to: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<AccessPattern>, Box<dyn std::error::Error + Send + Sync>>;
}

pub trait PredictionEngine: Send + Sync {
    fn predict_hot_data(
        &self,
        patterns: &[AccessPattern],
    ) -> Result<Vec<HotDataPrediction>, Box<dyn std::error::Error + Send + Sync>>;
}

#[derive(Debug, Clone)]
pub struct AccessPattern {
    pub key: String,
    pub data_type: String,
    pub access_count: u64,
    pub last_access: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct HotDataPrediction {
    pub data_type: String,
    pub keys: Vec<String>,
    pub confidence_score: f64,
}
```

### 4.2 智能批量聚合

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::oneshot;
use tokio::time::{timeout, Duration, Instant};

pub struct BatchOperationOptimizer {
    pending_batches: Arc<Mutex<HashMap<String, BatchRequest>>>,
}

impl BatchOperationOptimizer {
    pub fn new() -> Self {
        Self {
            pending_batches: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub async fn execute_with_batching<T, F, Fut>(
        &self,
        batch_key: String,
        batch_executor: F,
        request: T,
        max_wait_time: Duration,
    ) -> Result<T, Box<dyn std::error::Error + Send + Sync>>
    where
        T: Clone + Send + 'static,
        F: Fn(Vec<T>) -> Fut + Send + Sync + 'static,
        Fut: std::future::Future<Output = Result<HashMap<String, T>, Box<dyn std::error::Error + Send + Sync>>> + Send,
    {
        let (tx, rx) = oneshot::channel();
        
        // 获取或创建批量请求
        let batch_request = {
            let mut batches = self.pending_batches.lock().unwrap();
            batches.entry(batch_key.clone())
                .or_insert_with(|| {
                    BatchRequest::new(batch_key.clone(), max_wait_time)
                })
                .clone()
        };
        
        // 添加请求到批处理中
        batch_request.add_request(request.clone(), tx).await?;
        
        // 等待结果
        let result = timeout(max_wait_time * 2, rx).await??;
        Ok(result)
    }
}

#[derive(Clone)]
struct BatchRequest {
    batch_key: String,
    max_wait_time: Duration,
    created_at: Instant,
    // 实际实现会包含更多字段来管理批量请求
}

impl BatchRequest {
    fn new(batch_key: String, max_wait_time: Duration) -> Self {
        Self {
            batch_key,
            max_wait_time,
            created_at: Instant::now(),
        }
    }
    
    async fn add_request<T>(
        &self,
        request: T,
        tx: oneshot::Sender<T>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: Clone + Send + 'static,
    {
        // 实际实现会将请求添加到批处理队列中
        // 并在适当的时候触发批量执行
        todo!("实现批量请求聚合逻辑")
    }
}
```

## 5. 配置和部署

### 5.1 完整配置示例

**重要说明**：配置示例基于统一配置基础设施，只展示广告引擎特有的配置部分。

```toml
[data_providers.ad_candidate]
timeout_ms = 5
max_batch_size = 50

[data_providers.ad_candidate.cache_settings]
default_ttl = "5m"
sliding_expiration = true

[data_providers.user_profile]
timeout_ms = 20
max_batch_size = 100

[data_providers.user_profile.cache_settings]
default_ttl = "1h"
sliding_expiration = true

[data_providers.user_profile.privacy_mode]
enabled = true
data_masking = true
auto_expiration = true

[data_providers.targeting_config]
timeout_ms = 30
max_batch_size = 30

[data_providers.targeting_config.cache_settings]
default_ttl = "4h"
sliding_expiration = false

[data_providers.delivery_record]
timeout_ms = 10
max_batch_size = 200

[data_providers.delivery_record.cache_settings]
default_ttl = "30m"
sliding_expiration = true

[database.ad_engine]
url = "postgresql://username:password@localhost/ad_engine"
max_connections = 10
min_connections = 5
acquire_timeout = "30s"
idle_timeout = "600s"
max_lifetime = "1800s"

[cache.redis]
url = "redis://localhost:6379"
max_connections = 20
connection_timeout = "5s"
command_timeout = "10s"

[performance.warmup]
enabled = true
prediction_model = "ml_based"
warmup_schedule = "0 */6 * * *"  # 每6小时执行一次
```

### 5.2 依赖注入配置

**使用统一依赖注入基础设施**：

```rust
use lorn_adsp_infrastructure::dependency_injection::ServiceCollection;
use lorn_adsp_infrastructure::configuration::Config;

pub fn add_ad_engine_data_access(
    services: &mut ServiceCollection,
    config: &Config,
) -> Result<(), Box<dyn std::error::Error>> {
    // 广告引擎数据提供者注册（基于统一配置约定自动发现和注册）
    services.add_scoped::<dyn AdCandidateDataProvider, AdCandidateDataProviderImpl>();
    services.add_scoped::<dyn UserProfileDataProvider, UserProfileDataProviderImpl>();
    services.add_scoped::<dyn TargetingConfigDataProvider, TargetingConfigDataProviderImpl>();
    services.add_scoped::<dyn DeliveryRecordDataProvider, DeliveryRecordDataProviderImpl>();
    
    // 注册专用优化服务
    services.add_singleton::<PredictiveCacheWarmupService>();
    services.add_singleton::<BatchOperationOptimizer>();
    
    Ok(())
}
```

## 6. 总结

### 6.1 架构优势

1. **完全复用基础设施**：基于统一数据访问层的 `BusinessDataProviderBase` trait
2. **零重复实现**：所有缓存、路由、监控功能由基础设施自动提供
3. **业务专注性**：数据提供者只关注业务数据访问，不关心技术细节
4. **架构一致性**：与系统统一配置和依赖注入架构完全兼容

### 6.2 关键特性

- **基础设施透明**：开发者无需关心缓存和路由的技术实现
- **配置驱动**：通过配置文件控制所有数据访问行为
- **自动发现**：基于约定的组件自动注册和发现
- **性能保障**：基础实现自动提供性能监控和优化

### 6.3 实现指导

| 实现步骤   | 具体内容                                  | 注意事项                           |
| ---------- | ----------------------------------------- | ---------------------------------- |
| trait 定义 | 在 `core/ad_engine_abstractions` 包中定义 | 只定义 trait，不定义实体结构体     |
| 数据提供者 | 实现 `BusinessDataProviderBase` trait     | 专注业务逻辑，不实现基础设施       |
| 配置文件   | 添加 `data_providers` 配置节              | 使用统一配置基础设施的约定         |
| 服务注册   | 调用扩展方法注册服务                      | 基于统一依赖注入基础设施的自动发现 |

### 6.4 Rust 特有优势

- **内存安全**：避免空指针引用和内存泄漏问题
- **并发安全**：基于所有权系统的零成本并发
- **性能优异**：零成本抽象和编译时优化
- **类型安全**：强类型系统减少运行时错误

这个广告投放引擎数据访问层设计严格遵循"不重复造轮子"原则，充分利用系统现有的统一基础设施，为广告投放引擎提供了专业化且高效的 Rust 数据访问能力。
