# 数据模型关系修正说明

## 修正概述

根据系统架构设计的真实业务逻辑，对数据模型中的对象关系进行了重要修正，主要涉及定向配置（TargetingConfig）和广告候选（AdCandidate）的归属关系。

## 修正前的设计问题

### 1. TargetingConfig归属错误

**问题**：TargetingConfig直接关联到Advertisement
```
Advertisement (1) --> (1) TargetingConfig
```

**问题分析**：
- 一个广告（Advertisement）可能有多个投放活动（Campaign）
- 每个活动的投放策略和定向配置应该是独立的
- 将定向配置放在广告层面不符合实际业务场景

### 2. AdCandidate关联错误

**问题**：AdCandidate直接引用Advertisement
```
AdCandidate (1) --> (1) Advertisement
```

**问题分析**：
- 广告候选应该是针对具体的活动（Campaign）而非广告本身
- 在投放过程中，同一个广告的不同活动可能有不同的出价和定向策略
- AdCandidate应该关联到具体的Campaign

## 修正后的设计

### 1. 正确的层次关系

```
Advertisement (1) --> (0..*) Campaign
Campaign (1) --> (1) TargetingConfig
AdCandidate (1) --> (1) Campaign
```

### 2. 修正的数据模型关系

#### Advertisement实体修正
- **移除**：targeting_config属性
- **移除**：delivery_policy属性  
- **增加**：add_campaign方法
- **增加**：get_active_campaigns方法

#### Campaign实体修正
- **增加**：targeting_config属性
- **增加**：delivery_policy属性
- **增加**：update_targeting方法
- **增加**：create_targeting_from_policy方法

#### AdCandidate实体修正
- **修改**：从advertisement_id改为campaign_id
- **修改**：从advertisement属性改为campaign属性
- **增加**：get_advertisement方法（通过Campaign间接获取）

#### TargetingConfig实体修正
- **修改**：从advertisement_id改为campaign_id
- **修改**：create_from_policy方法参数从advertisement_id改为campaign_id

## 修正影响的文件

### 1. 技术设计文档
- `docs_TecDesign/广告投放引擎/数据模型分层设计.md`
- `docs_TecDesign/广告投放引擎/广告引擎抽象层设计.md`

### 2. 产品设计文档
- `docs_ProductDesign/广告投放引擎/数据模型设计.md`

### 3. Rust代码实现文件

- `crates/04-core/domain/src/entities/advertisement.rs`
- `crates/04-core/domain/src/entities/campaign.rs`
- `crates/04-core/domain/src/entities/targeting_config.rs`
- `crates/04-core/domain/src/entities/ad_candidate.rs`
- `crates/05-infrastructure/data-abstractions/src/repositories/`

### 4. Rust特定的实现注意事项

#### 所有权和借用
```rust
// 避免不必要的克隆，使用引用
impl AdCandidate {
    pub fn get_advertisement(&self) -> Option<&Advertisement> {
        self.campaign.as_ref().map(|c| &c.advertisement)
    }
    
    pub fn get_targeting_config(&self) -> Option<&TargetingConfig> {
        self.campaign.as_ref().and_then(|c| c.targeting_config.as_ref())
    }
}

// 在需要所有权转移时才克隆
impl Campaign {
    pub fn create_ad_candidate(&self) -> Result<AdCandidate, String> {
        if self.status != CampaignStatus::Active {
            return Err("Campaign is not active".to_string());
        }
        
        Ok(AdCandidate {
            campaign_id: self.id,
            campaign: Some(self.clone()), // 这里需要克隆
            ..Default::default()
        })
    }
}
```

#### SeaORM关联关系配置
```rust
// Campaign实体关联配置
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::advertisement::Entity",
        from = "Column::AdvertisementId",
        to = "super::advertisement::Column::Id"
    )]
    Advertisement,
    
    #[sea_orm(
        has_one = "super::targeting_config::Entity",
        from = "Column::Id",
        to = "super::targeting_config::Column::CampaignId"
    )]
    TargetingConfig,
}

// TargetingConfig实体关联配置
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::campaign::Entity",
        from = "Column::CampaignId",
        to = "super::campaign::Column::Id"
    )]
    Campaign,
}
```

## 业务逻辑改进

### 1. 更符合实际业务场景

**广告创建流程**：
1. 广告主创建Advertisement（广告信息）
2. 为Advertisement创建多个Campaign（投放活动）
3. 每个Campaign配置独立的TargetingConfig（定向策略）
4. 每个Campaign可以有不同的预算、时间、出价策略

**广告投放流程**：
1. 广告引擎召回候选Campaign
2. 创建AdCandidate关联到具体Campaign
3. 使用Campaign的TargetingConfig进行定向匹配
4. 通过Campaign.Advertisement获取广告素材信息

### 2. 支持更灵活的投放策略

**多活动场景**：
- 同一个广告可以同时投放多个活动
- 不同活动可以针对不同受众群体
- 不同活动可以有不同的出价策略和预算控制

**A/B测试支持**：
- 同一个广告的不同Campaign可以测试不同的定向策略
- 可以对比不同定向配置的效果
- 支持逐步优化投放策略

## 迁移指南

### 1. 代码层面的调整

如果有现有的实现代码，需要进行以下调整：

```rust
// 修正前
let targeting_config = advertisement.targeting_config;
let ad_candidate = AdCandidate {
    advertisement_id: advertisement.id,
    advertisement: Some(advertisement),
    ..Default::default()
};

// 修正后
let campaign = advertisement.campaigns
    .iter()
    .find(|c| c.status == CampaignStatus::Active)
    .ok_or("No active campaign found")?;
let targeting_config = &campaign.targeting_config;
let ad_candidate = AdCandidate {
    campaign_id: campaign.id,
    campaign: Some(campaign.clone()),
    ..Default::default()
};
```

### 2. 数据库模式调整

```sql
-- TargetingConfig表结构调整
ALTER TABLE targeting_configs 
DROP COLUMN advertisement_id;

ALTER TABLE targeting_configs 
ADD COLUMN campaign_id BIGINT NOT NULL;

-- AdCandidate表结构调整（注意：AdCandidate是临时对象，通常不持久化到数据库）
-- 如果需要持久化AdCandidate，则进行以下调整：
ALTER TABLE ad_candidates 
DROP COLUMN advertisement_id;

ALTER TABLE ad_candidates 
ADD COLUMN campaign_id BIGINT NOT NULL;

-- 添加外键约束
ALTER TABLE targeting_configs 
ADD CONSTRAINT fk_targeting_configs_campaign_id 
FOREIGN KEY (campaign_id) REFERENCES campaigns(id);

-- 如果AdCandidate表存在，添加外键约束
ALTER TABLE ad_candidates 
ADD CONSTRAINT fk_ad_candidates_campaign_id 
FOREIGN KEY (campaign_id) REFERENCES campaigns(id);
```

## 总结

这次修正解决了数据模型设计中的重要架构问题，使系统设计更加符合实际的广告投放业务场景。修正后的Rust实现设计具有以下优势：

1. **业务逻辑清晰**：明确了广告-活动-定向配置的层次关系
2. **灵活性增强**：支持一个广告多个活动的复杂投放场景  
3. **扩展性提升**：为未来的功能扩展提供了更好的架构基础
4. **符合实际**：与真实的广告平台业务流程保持一致
5. **类型安全**：利用Rust的类型系统在编译时捕获关系错误
6. **内存安全**：通过所有权模型避免数据竞争和内存泄漏
7. **异步支持**：与SeaORM和Tokio生态系统完美集成

### Rust特有的优势

- **编译时验证**：关系错误在编译时被发现，而不是运行时
- **零成本抽象**：关联关系不会带来运行时性能开销
- **并发安全**：`Send` + `Sync` traits确保数据在多线程环境下的安全性
- **错误处理**：`Result<T, E>` 类型强制显式处理数据库操作错误

修正后的设计将为后续的Rust系统实现提供更加合理、安全和高性能的架构基础。
