# 广告效果监测服务数据访问层设计

## 设计概述

广告效果监测服务数据访问层基于广告引擎抽象层架构，通过trait对象和依赖注入机制实现与具体数据存储技术的完全解耦。设计遵循仓储模式(Repository Pattern)，基于Rust异步编程和SeaORM，提供高性能、内存安全的监测数据存储和查询能力，支持大规模监测数据的批量写入和实时统计查询。

## 数据访问架构设计

### 整体架构图

```mermaid
graph TB
    subgraph "监测服务数据访问架构"
        A[监测服务业务层] --> B[广告引擎抽象层]
        B --> C[trait对象抽象层]
        C --> D[trait实现层]
        D --> E[仓储trait层]
        E --> F[仓储实现层]
        F --> G[SeaORM数据访问层]
        G --> H[数据库提供程序]
        
        subgraph "trait抽象接口"
            I[MonitoringDataService<br/>监测数据服务trait]
            J[StatisticsService<br/>统计数据服务trait]
            K[ConfigurationService<br/>配置数据服务trait]
            L[NotificationService<br/>通知服务trait]
        end
        
        subgraph "仓储trait层"
            M[MonitoringLogRepository<br/>监测日志仓储trait]
            N[StatisticsSnapshotRepository<br/>统计快照仓储trait]
            O[MonitoringConfigRepository<br/>配置仓储trait]
            P[QualityAssessmentRepository<br/>质量评估仓储trait]
        end
        
        subgraph "数据存储层"
            Q[监测日志数据库<br/>分表分区存储]
            R[统计数据缓存<br/>Redis集群]
            S[配置数据存储<br/>PostgreSQL/MySQL]
            T[质量评估存储<br/>时序数据库]
        end
        
        C -.-> I
        C -.-> J
        C -.-> K
        C -.-> L
        
        E -.-> M
        E -.-> N
        E -.-> O
        E -.-> P
        
        G -.-> Q
        G -.-> R
        G -.-> S
        G -.-> T
    end
```

### 数据访问流程设计

```mermaid
sequenceDiagram
    participant MS as 监测服务
    participant AE as 广告引擎抽象层
    participant TS as trait服务
    participant Impl as trait实现
    participant Repo as 仓储trait
    participant DB as 数据存储
    
    MS->>AE: 调用数据访问方法
    AE->>TS: 通过trait对象访问
    TS->>Impl: 调用具体实现
    Impl->>Repo: 使用仓储trait
    Repo->>DB: 执行异步数据库操作
    DB-->>Repo: 返回Result<T, E>
    Repo-->>Impl: 返回领域对象
    Impl-->>TS: 返回Future<Result<T, E>>
    TS-->>AE: 返回抽象结果
    AE-->>MS: 返回业务结果
```

## trait接口设计

### 监测数据访问服务trait

```mermaid
classDiagram
    class MonitoringDataService {
        <<trait>>
        +batch_insert_monitoring_logs() Future~Result~i32, AppError~~
        +insert_monitoring_log() Future~Result~bool, AppError~~
        +get_monitoring_logs_by_date_range() Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +get_monitoring_logs_by_adspace() Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +get_monitoring_logs_by_campaign() Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +get_monitoring_logs_paged() Future~Result~PagedResult~MonitoringLogEntry~, AppError~~
        +get_monitoring_logs_count() Future~Result~i64, AppError~~
        +exists_monitoring_log() Future~Result~bool, AppError~~
        +get_event_counts_by_type() Future~Result~HashMap~String, i64~, AppError~~
        +update_processing_status() Future~Result~bool, AppError~~
        +batch_delete_old_logs() Future~Result~i32, AppError~~
        +validate_data_integrity() Future~Result~ValidationResult, AppError~~
    }
    
    class StatisticsService {
        <<trait>>
        +update_real_time_stats() Future~Result~bool, AppError~~
        +get_statistics_by_period() Future~Result~Vec~StatisticsSnapshot~, AppError~~
        +create_statistics_snapshot() Future~Result~bool, AppError~~
        +get_dashboard_stats() Future~Result~DashboardStats, AppError~~
        +batch_update_stats() Future~Result~i32, AppError~~
        +get_stats_comparison() Future~Result~StatsComparison, AppError~~
        +clear_expired_stats() Future~Result~i32, AppError~~
        +recalculate_stats() Future~Result~bool, AppError~~
    }
    
    class ConfigurationService {
        <<trait>>
        +get_active_config() Future~Result~MonitoringConfig, AppError~~
        +update_config() Future~Result~bool, AppError~~
        +get_config_history() Future~Result~Vec~MonitoringConfig~, AppError~~
        +validate_config() Future~Result~ValidationResult, AppError~~
        +backup_config() Future~Result~bool, AppError~~
        +restore_config() Future~Result~bool, AppError~~
    }
    
    class NotificationService {
        <<trait>>
        +send_alert() Future~Result~bool, AppError~~
        +log_system_event() Future~Result~bool, AppError~~
        +get_notification_history() Future~Result~Vec~Notification~, AppError~~
        +update_notification_status() Future~Result~bool, AppError~~
    }
```

### 3.1 监测数据服务trait详细设计

**项目位置**: `crates/04-core/domain/src/services/monitoring_data_service.rs`

**设计职责**:

- 提供监测日志数据的完整CRUD操作trait
- 支持批量高性能数据写入和查询操作
- 实现监测数据的生命周期管理
- 提供数据统计和分析支持

**核心方法设计**:

1. **数据写入方法**:

   - `batch_insert_monitoring_logs`: 批量插入监测日志，支持事务处理
   - `insert_monitoring_log`: 单条记录插入，用于特殊场景

2. **数据查询方法**:

   - `get_monitoring_logs_by_date_range`: 按时间范围查询，支持跨表查询
   - `get_monitoring_logs_by_adspace`: 按广告位查询，用于效果分析
   - `get_monitoring_logs_by_campaign`: 按活动查询，支持活动效果统计
   - `get_monitoring_logs_paged`: 分页查询，支持大数据量展示

3. **数据管理方法**:

   - `get_monitoring_logs_count`: 获取记录总数，用于统计和监控
   - `exists_monitoring_log`: 检查记录存在性，支持重复检测
   - `update_processing_status`: 更新处理状态，支持工作流跟踪
   - `batch_delete_old_logs`: 批量删除历史数据，支持数据归档

**Rust trait实现示例**:

```rust
use async_trait::async_trait;
use std::collections::HashMap;
use chrono::{DateTime, Utc};

#[async_trait]
pub trait MonitoringDataService: Send + Sync {
    async fn batch_insert_monitoring_logs(
        &self,
        logs: Vec<MonitoringLogEntry>,
    ) -> Result<i32, AppError>;
    
    async fn get_monitoring_logs_by_date_range(
        &self,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>,
        limit: Option<u64>,
    ) -> Result<Vec<MonitoringLogEntry>, AppError>;
    
    async fn get_event_counts_by_type(
        &self,
        date_range: DateRange,
        filters: Option<HashMap<String, String>>,
    ) -> Result<HashMap<String, i64>, AppError>;
}
```

### 3.2 统计数据服务trait详细设计

**项目位置**: `crates/04-core/domain/src/services/statistics_service.rs`

**设计职责**:

- 提供实时统计数据的存储和查询功能
- 支持多维度统计数据的聚合计算
- 实现统计快照和历史数据管理
- 提供统计数据的对比和分析功能

**核心方法设计**:

1. **实时统计方法**:

   - `update_real_time_stats`: 更新实时统计数据，支持原子操作
   - `get_statistics_by_period`: 按时间周期查询统计数据
   - `batch_update_stats`: 批量更新统计数据，提高性能

2. **快照管理方法**:

   - `create_statistics_snapshot`: 创建统计快照，支持定期备份
   - `get_dashboard_stats`: 获取仪表板统计数据
   - `get_stats_comparison`: 获取统计对比数据，支持同比环比

3. **数据维护方法**:

   - `clear_expired_stats`: 清理过期统计数据
   - `recalculate_stats`: 重新计算统计数据，支持数据修复

**Rust trait实现示例**:

```rust
#[async_trait]
pub trait StatisticsService: Send + Sync {
    async fn update_real_time_stats(
        &self,
        adspace_id: i32,
        stats_update: StatsUpdate,
    ) -> Result<bool, AppError>;
    
    async fn get_dashboard_stats(
        &self,
        user_id: i32,
        date_range: DateRange,
    ) -> Result<DashboardStats, AppError>;
    
    async fn create_statistics_snapshot(
        &self,
        snapshot_type: SnapshotType,
        metadata: HashMap<String, String>,
    ) -> Result<bool, AppError>;
}
```

## 仓储trait设计

### 4.1 监测日志仓储trait

```mermaid
classDiagram
    class MonitoringLogRepository {
        <<trait>>
        +create(entity) Future~Result~MonitoringLogEntry, AppError~~
        +create_many(entities) Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +update(entity) Future~Result~MonitoringLogEntry, AppError~~
        +delete(id) Future~Result~bool, AppError~~
        +find_by_id(id) Future~Result~Option~MonitoringLogEntry~, AppError~~
        +find_by_event_id(event_id) Future~Result~Option~MonitoringLogEntry~, AppError~~
        +find_paged(page_index, page_size) Future~Result~PagedResult~MonitoringLogEntry~, AppError~~
        +find_by_date_range(start_date, end_date) Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +find_by_campaign(campaign_id) Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +find_by_adspace(adspace_id) Future~Result~Vec~MonitoringLogEntry~, AppError~~
        +count_by_predicate(predicate) Future~Result~i64, AppError~~
        +exists_by_predicate(predicate) Future~Result~bool, AppError~~
        +batch_delete_by_predicate(predicate) Future~Result~i32, AppError~~
    }
    
    class Repository~T~ {
        <<trait>>
        +create(entity) Future~Result~T, AppError~~
        +update(entity) Future~Result~T, AppError~~
        +delete(id) Future~Result~bool, AppError~~
        +find_by_id(id) Future~Result~Option~T~, AppError~~
        +find_all() Future~Result~Vec~T~, AppError~~
        +find_by_predicate(predicate) Future~Result~Vec~T~, AppError~~
        +count_by_predicate(predicate) Future~Result~i64, AppError~~
        +exists_by_predicate(predicate) Future~Result~bool, AppError~~
    }
    
    MonitoringLogRepository --|> Repository~MonitoringLogEntry~
```

**项目位置**: `crates/04-core/domain/src/repositories/monitoring_log_repository.rs`

**设计职责**:

- 继承通用仓储trait `Repository<MonitoringLogEntry>`
- 提供监测日志特定的查询和操作方法
- 支持大规模数据的高性能查询
- 实现数据分页和条件过滤

**核心方法设计**:

1. **批量操作方法**:

   - `create_many`: 批量添加监测日志，支持事务控制
   - `batch_delete_by_predicate`: 批量删除操作，支持条件删除

2. **专用查询方法**:

   - `find_by_event_id`: 按事件ID查询，支持去重检查
   - `find_by_date_range`: 按时间范围查询，支持分区优化
   - `find_by_campaign`: 按活动查询，支持活动效果分析
   - `find_by_adspace`: 按广告位查询，支持媒体效果分析

**Rust trait实现示例**:

```rust
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sea_orm::prelude::*;

#[async_trait]
pub trait MonitoringLogRepository: Repository<MonitoringLogEntry> + Send + Sync {
    async fn find_by_event_id(
        &self,
        event_id: &str,
    ) -> Result<Option<MonitoringLogEntry>, AppError>;
    
    async fn find_by_date_range(
        &self,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>,
        limit: Option<u64>,
        offset: Option<u64>,
    ) -> Result<Vec<MonitoringLogEntry>, AppError>;
    
    async fn create_many(
        &self,
        entities: Vec<MonitoringLogEntry>,
    ) -> Result<Vec<MonitoringLogEntry>, AppError>;
    
    async fn batch_delete_by_predicate(
        &self,
        condition: sea_orm::Condition,
    ) -> Result<i32, AppError>;
}
```

### 4.2 统计快照仓储trait

**项目位置**: `crates/04-core/domain/src/repositories/statistics_snapshot_repository.rs`

**设计职责**:

- 管理统计快照数据的存储和查询
- 支持多维度统计数据的聚合操作
- 实现统计数据的版本管理和历史追踪
- 提供统计数据的对比和趋势分析

**核心方法设计**:

1. **快照管理方法**:

   - `create_snapshot`: 创建统计快照
   - `get_latest_snapshot`: 获取最新快照数据
   - `get_snapshots_by_period`: 按周期获取快照历史
   - `compare_snapshots`: 对比不同时期的快照数据

2. **聚合查询方法**:

   - `get_aggregated_stats`: 获取聚合统计数据
   - `get_trend_analysis`: 获取趋势分析数据
   - `get_top_performing_ads`: 获取表现最佳的广告

**Rust trait实现示例**:

```rust
#[async_trait]
pub trait StatisticsSnapshotRepository: Repository<StatisticsSnapshot> + Send + Sync {
    async fn create_snapshot(
        &self,
        snapshot_type: SnapshotType,
        data: StatisticsData,
        metadata: HashMap<String, String>,
    ) -> Result<StatisticsSnapshot, AppError>;
    
    async fn get_latest_snapshot(
        &self,
        snapshot_type: SnapshotType,
        scope: StatisticsScope,
    ) -> Result<Option<StatisticsSnapshot>, AppError>;
    
    async fn get_snapshots_by_period(
        &self,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>,
        granularity: TimeGranularity,
    ) -> Result<Vec<StatisticsSnapshot>, AppError>;
    
    async fn compare_snapshots(
        &self,
        snapshot1_id: i32,
        snapshot2_id: i32,
    ) -> Result<StatsComparison, AppError>;
}
```

## SeaORM数据访问层设计

### 5.1 监测数据实体定义

```mermaid
classDiagram
    class MonitoringLogEntry {
        +id i32
        +event_id String
        +event_type String
        +timestamp DateTime~Utc~
        +adspace_id i32
        +ad_id Option~i32~
        +campaign_id Option~i32~
        +user_id Option~String~
        +device_info Option~String~
        +location_info Option~String~
        +custom_properties Option~String~
        +processing_status String
        +created_at DateTime~Utc~
        +updated_at DateTime~Utc~
    }
    
    class StatisticsSnapshot {
        +id i32
        +snapshot_type String
        +scope_type String
        +scope_id i32
        +snapshot_date DateTime~Utc~
        +statistics_data String
        +metadata Option~String~
        +version i32
        +created_at DateTime~Utc~
    }
    
    class MonitoringConfiguration {
        +id i32
        +name String
        +config_type String
        +config_data String
        +is_active bool
        +version i32
        +effective_from DateTime~Utc~
        +effective_to Option~DateTime~Utc~~
        +created_by i32
        +created_at DateTime~Utc~
        +updated_by Option~i32~
        +updated_at Option~DateTime~Utc~~
    }
```

### 5.2 SeaORM实体映射

在Rust中，我们使用SeaORM的derive宏来定义实体映射：

```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "monitoring_logs")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    
    #[sea_orm(column_type = "String(Some(50))")]
    pub event_id: String,
    
    #[sea_orm(column_type = "String(Some(50))")]
    pub event_type: String,
    
    pub timestamp: DateTime<Utc>,
    
    pub adspace_id: i32,
    
    pub ad_id: Option<i32>,
    
    pub campaign_id: Option<i32>,
    
    #[sea_orm(column_type = "String(Some(100))")]
    pub user_id: Option<String>,
    
    #[sea_orm(column_type = "Text")]
    pub device_info: Option<String>,
    
    #[sea_orm(column_type = "Text")]
    pub location_info: Option<String>,
    
    #[sea_orm(column_type = "Text")]
    pub custom_properties: Option<String>,
    
    #[sea_orm(column_type = "String(Some(20))")]
    pub processing_status: String,
    
    pub created_at: DateTime<Utc>,
    
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::adspace::Entity",
        from = "Column::AdspaceId",
        to = "super::adspace::Column::Id"
    )]
    Adspace,
}

impl Related<super::adspace::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Adspace.def()
    }
}

impl ActiveModelBehavior for ActiveModel {
    fn new() -> Self {
        Self {
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..ActiveModelTrait::default()
        }
    }

    fn before_save<C>(mut self, _db: &C, _insert: bool) -> Result<Self, DbErr>
    where
        C: ConnectionTrait,
    {
        self.updated_at = Set(Utc::now());
        Ok(self)
    }
}
```

**项目位置**: `crates/05-infrastructure/data-abstractions/src/entities/monitoring_log.rs`

**设计职责**:

- 管理监测相关实体的数据库映射
- 提供SeaORM配置和优化
- 实现关系映射和约束定义
- 支持自动时间戳更新和数据验证

**核心实体模块**:

1. **核心实体模块**:

   - `monitoring_logs`: 监测日志实体模块
   - `statistics_snapshots`: 统计快照实体模块
   - `monitoring_configurations`: 监测配置实体模块
   - `quality_assessments`: 质量评估实体模块

2. **连接管理功能**:

   - `create_connection_pool`: 创建数据库连接池
   - `get_connection`: 获取数据库连接
   - `begin_transaction`: 开始事务处理
   - `rollback_transaction`: 回滚事务操作

3. **批量操作方法**:

   - `bulk_insert_async`: 异步批量插入操作
   - `bulk_update_async`: 异步批量更新操作
   - `bulk_delete_async`: 异步批量删除操作
   - `execute_raw_sql`: 执行原生SQL查询

### 5.3 SeaORM连接池配置

**项目位置**: `crates/05-infrastructure/data-abstractions/src/config/monitoring_config.rs`

```rust
use sea_orm::{Database, DatabaseConnection, ConnectOptions};
use std::time::Duration;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringDataConfig {
    pub database_url: String,
    pub max_connections: u32,
    pub min_connections: u32,
    pub connect_timeout: Duration,
    pub idle_timeout: Duration,
    pub acquire_timeout: Duration,
    pub max_lifetime: Option<Duration>,
}

impl MonitoringDataConfig {
    pub async fn create_connection_pool(&self) -> Result<DatabaseConnection, sea_orm::DbErr> {
        let mut opt = ConnectOptions::new(&self.database_url);
        opt.max_connections(self.max_connections)
            .min_connections(self.min_connections)
            .connect_timeout(self.connect_timeout)
            .idle_timeout(self.idle_timeout)
            .acquire_timeout(self.acquire_timeout)
            .sqlx_logging(true)
            .sqlx_logging_level(log::LevelFilter::Debug);
            
        if let Some(lifetime) = self.max_lifetime {
            opt.max_lifetime(lifetime);
        }
            
        Database::connect(opt).await
    }
    
    pub fn default() -> Self {
        Self {
            database_url: "postgresql://user:password@localhost/monitoring".to_string(),
            max_connections: 100,
            min_connections: 5,
            connect_timeout: Duration::from_secs(30),
            idle_timeout: Duration::from_secs(600),
            acquire_timeout: Duration::from_secs(30),
            max_lifetime: Some(Duration::from_secs(3600)),
        }
    }
}
```

## 分区和缓存策略

### 6.1 数据分区设计

```mermaid
graph TD
    A[监测日志表] --> B[按时间分区]
    A --> C[按广告主分区]
    
    B --> D[日分区表]
    B --> E[月分区表]
    B --> F[年分区表]
    
    C --> G[广告主A分区]
    C --> H[广告主B分区]
    
    I[分区管理器] --> J[自动分区创建]
    I --> K[历史数据归档]
    I --> L[分区性能监控]
```

**项目位置**: `crates/05-infrastructure/data-abstractions/src/partitioning/mod.rs`

**分区策略实现**:

```rust
use sea_orm::{DatabaseConnection, Statement, DbBackend};
use chrono::{DateTime, Utc, Duration};
use std::collections::HashMap;

pub struct PartitionManager {
    db: DatabaseConnection,
    partition_config: PartitionConfig,
}

#[derive(Debug, Clone)]
pub struct PartitionConfig {
    pub table_name: String,
    pub partition_type: PartitionType,
    pub retention_days: i64,
    pub auto_create: bool,
}

#[derive(Debug, Clone)]
pub enum PartitionType {
    Daily,
    Monthly,
    Yearly,
    ByAdvertiser,
}

impl PartitionManager {
    pub fn new(db: DatabaseConnection, config: PartitionConfig) -> Self {
        Self {
            db,
            partition_config: config,
        }
    }
    
    pub async fn create_time_partition(
        &self,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>,
    ) -> Result<String, sea_orm::DbErr> {
        let partition_name = match self.partition_config.partition_type {
            PartitionType::Daily => format!("{}_{}", 
                self.partition_config.table_name,
                start_date.format("%Y_%m_%d")
            ),
            PartitionType::Monthly => format!("{}_{}", 
                self.partition_config.table_name,
                start_date.format("%Y_%m")
            ),
            PartitionType::Yearly => format!("{}_{}", 
                self.partition_config.table_name,
                start_date.format("%Y")
            ),
            _ => return Err(sea_orm::DbErr::Custom("Invalid partition type for time partitioning".to_string())),
        };
        
        let sql = format!(
            "CREATE TABLE IF NOT EXISTS {} PARTITION OF {} 
             FOR VALUES FROM ('{}') TO ('{}')",
            partition_name,
            self.partition_config.table_name,
            start_date.format("%Y-%m-%d %H:%M:%S"),
            end_date.format("%Y-%m-%d %H:%M:%S")
        );
        
        self.db.execute(Statement::from_string(DbBackend::Postgres, sql)).await?;
        Ok(partition_name)
    }
    
    pub async fn cleanup_old_partitions(&self) -> Result<Vec<String>, sea_orm::DbErr> {
        let cutoff_date = Utc::now() - Duration::days(self.partition_config.retention_days);
        let mut dropped_partitions = Vec::new();
        
        // 查询需要删除的分区
        let partitions = self.get_partitions_before_date(cutoff_date).await?;
        
        for partition_name in partitions {
            let sql = format!("DROP TABLE IF EXISTS {}", partition_name);
            self.db.execute(Statement::from_string(DbBackend::Postgres, sql)).await?;
            dropped_partitions.push(partition_name);
        }
        
        Ok(dropped_partitions)
    }
    
    async fn get_partitions_before_date(
        &self,
        cutoff_date: DateTime<Utc>,
    ) -> Result<Vec<String>, sea_orm::DbErr> {
        // 实现获取过期分区的逻辑
        Ok(vec![])
    }
}
```

### 6.2 分区策略配置

**分区策略设计**:

1. **监测日志分区**:

   - 按日期分区: 提高查询性能和维护效率
   - 按广告主分区: 支持租户隔离和并行查询
   - 自动分区管理: 定期创建新分区和清理历史分区

2. **统计数据分区**:

   - 按时间维度分区: 支持不同粒度的统计查询
   - 按业务维度分区: 提高特定查询的性能

3. **分区维护**:

4. **按广告主分区**:

   - 租户数据隔离: 确保不同广告主数据的安全隔离
   - 并行查询优化: 支持多个广告主数据的并行处理
   - 资源配额管理: 控制单个广告主的资源使用

### 6.2 缓存策略设计

```mermaid
graph TB
    subgraph "多级缓存架构"
        A[应用内存缓存 L1] --> B[Redis分布式缓存 L2]
        B --> C[数据库查询 L3]
        
        subgraph "L1缓存策略"
            D[热点数据缓存<br/>容量: 100MB<br/>TTL: 5分钟]
            E[查询结果缓存<br/>容量: 200MB<br/>TTL: 15分钟]
        end
        
        subgraph "L2缓存策略"
            F[统计数据缓存<br/>TTL: 1小时]
            G[配置数据缓存<br/>TTL: 24小时]
            H[会话数据缓存<br/>TTL: 30分钟]
        end
        
        A --> D
        A --> E
        B --> F
        B --> G
        B --> H
    end
```

**缓存设计要求**:

1. **L1内存缓存**:

   - 热点数据缓存: 频繁访问的统计数据和配置信息
   - 查询结果缓存: 复杂查询的结果集缓存
   - 过期策略: 基于LRU算法的自动过期和清理

2. **L2分布式缓存**:

   - 统计数据缓存: 实时统计数据和历史趋势数据
   - 配置数据缓存: 系统配置和业务规则缓存
   - 集群支持: Redis集群模式，支持高可用和负载均衡

3. **缓存更新策略**:

   - Write-Through: 同步更新缓存和数据库
   - Write-Behind: 批量异步写入，提高性能
   - Cache-Aside: 应用程序管理缓存更新逻辑

4. **一致性保证**:

   - 版本控制: 使用版本号确保数据一致性
   - 分布式锁: Redis分布式锁防止并发更新冲突
   - 事件通知: 数据变更事件通知缓存更新

## 性能优化设计

### 7.1 Rust查询优化

**项目位置**: `crates/05-infrastructure/data-abstractions/src/optimization/query_optimizer.rs`

```mermaid
graph LR
    subgraph "查询优化策略"
        A[索引优化] --> B[查询计划优化]
        B --> C[分页查询优化]
        C --> D[批量查询优化]
        D --> E[缓存查询优化]
        
        subgraph "索引设计"
            F[主键索引]
            G[唯一索引]
            H[复合索引]
            I[覆盖索引]
        end
        
        subgraph "查询策略"
            J[参数化查询]
            K[预编译语句]
            L[批量操作]
            M[异步查询]
        end
        
        A --> F
        A --> G
        A --> H
        A --> I
        
        B --> J
        B --> K
        B --> L
        B --> M
    end
```

**性能优化要求**:

1. **查询性能指标**:

   - 单次查询响应时间 < 100ms
   - 批量操作吞吐量 > 10000 TPS
   - 并发查询支持 > 1000 连接
   - 缓存命中率 > 95%

2. **优化策略**:

   - 索引优化: 为常用查询字段创建合适的索引
   - 查询优化: 使用查询计划分析和SQL优化
   - 连接池优化: 合理配置数据库连接池参数
   - 批量操作: 使用批量插入和更新提高性能

## 开发实现指导

### 8.1 Visual Studio项目结构

## 实施指导

### 8.1 Cargo工作空间项目组织

**项目组织要求**:

- `crates/04-core/domain/src/services/`目录实现所有service trait定义
- 每个service trait单独文件，命名规范为`{功能名}_service.rs`
- `crates/05-infrastructure/data-abstractions/src/repositories/`目录定义仓储trait
- 仓储trait命名规范为`{实体名}_repository.rs`
- `crates/05-infrastructure/data-{provider}/src/repositories/`目录实现仓储
- 仓储实现命名规范为`{实体名}_repository_impl.rs`
- `crates/05-infrastructure/caching-{provider}/src/`目录实现缓存provider
- 缓存实现命名规范为`{provider_name}_cache.rs`

### 8.2 配置管理

**项目位置**: `crates/05-infrastructure/config-abstractions/src/monitoring_config.rs`

```rust
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringDataAccessConfig {
    pub database: DatabaseConfig,
    pub cache: CacheConfig,
    pub performance: PerformanceConfig,
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub provider: DatabaseProvider,
    pub connection_string: String,
    pub max_connections: u32,
    pub min_connections: u32,
    pub connection_timeout: Duration,
    pub command_timeout: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DatabaseProvider {
    PostgreSQL,
    MySQL,
    SQLite,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheConfig {
    pub provider: CacheProvider,
    pub connection_string: Option<String>,
    pub default_ttl: Duration,
    pub max_memory_mb: u64,
    pub cleanup_interval: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CacheProvider {
    InMemory,
    Redis,
    Distributed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceConfig {
    pub slow_query_threshold: Duration,
    pub batch_size: usize,
    pub query_timeout: Duration,
    pub retry_attempts: u32,
    pub circuit_breaker_threshold: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub enable_query_logging: bool,
    pub enable_performance_metrics: bool,
    pub log_level: String,
    pub metrics_collection_interval: Duration,
}
```

### 8.3 依赖注入配置

**项目位置**: `crates/05-infrastructure/di-impl/src/monitoring_module.rs`

```rust
use std::sync::Arc;
use async_trait::async_trait;
use crate::config::MonitoringDataAccessConfig;

#[async_trait]
pub trait ServiceContainer: Send + Sync {
    async fn register_monitoring_services(&mut self, config: MonitoringDataAccessConfig) -> Result<(), DIError>;
}

pub struct MonitoringServiceModule;

impl MonitoringServiceModule {
    pub async fn configure_services(
        container: &mut dyn ServiceContainer,
        config: MonitoringDataAccessConfig,
    ) -> Result<(), DIError> {
        // 注册数据库连接
        container.register_singleton(
            create_database_connection(config.database).await?
        ).await?;
        
        // 注册缓存服务
        container.register_singleton(
            create_cache_service(config.cache).await?
        ).await?;
        
        // 注册仓储实现
        container.register_scoped::<dyn MonitoringLogRepository>(
            |provider| Box::new(SeaORMMonitoringLogRepository::new(
                provider.get::<DatabaseConnection>().unwrap()
            ))
        ).await?;
        
        container.register_scoped::<dyn StatisticsSnapshotRepository>(
            |provider| Box::new(SeaORMStatisticsSnapshotRepository::new(
                provider.get::<DatabaseConnection>().unwrap()
            ))
        ).await?;
        
        // 注册服务层
        container.register_scoped::<dyn MonitoringDataService>(
            |provider| Box::new(MonitoringDataServiceImpl::new(
                provider.get::<dyn MonitoringLogRepository>().unwrap(),
                provider.get::<dyn MonitoringCache>().unwrap(),
            ))
        ).await?;
        
        Ok(())
    }
}

#[derive(Debug, thiserror::Error)]
pub enum DIError {
    #[error("Service registration failed: {0}")]
    Registration(String),
    
    #[error("Service resolution failed: {0}")]
    Resolution(String),
    
    #[error("Configuration error: {0}")]
    Configuration(String),
}
```

### 8.4 单元测试指导

**项目位置**: `crates/08-tests/unit/src/monitoring/`

```rust
use tokio_test;
use mockall::predicate::*;
use sea_orm::{DatabaseBackend, MockDatabase, MockExecResult, Transaction};
use crate::monitoring::*;

#[tokio::test]
async fn test_monitoring_log_repository_batch_insert() {
    // 模拟数据库
    let db = MockDatabase::new(DatabaseBackend::Postgres)
        .append_exec_results([MockExecResult {
            last_insert_id: 1,
            rows_affected: 3,
        }])
        .into_connection();
    
    let repository = SeaORMMonitoringLogRepository::new(db);
    
    let logs = vec![
        create_test_monitoring_log("event1"),
        create_test_monitoring_log("event2"),
        create_test_monitoring_log("event3"),
    ];
    
    let result = repository.batch_insert_monitoring_logs(logs).await;
    
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 3);
}

#[tokio::test]
async fn test_monitoring_cache_operations() {
    let cache = InMemoryCache::new();
    
    // 测试设置和获取
    let test_data = vec![1, 2, 3, 4, 5];
    cache.set("test_key", &test_data, Some(Duration::from_secs(60))).await.unwrap();
    
    let retrieved: Option<Vec<i32>> = cache.get("test_key").await.unwrap();
    assert_eq!(retrieved, Some(test_data));
    
    // 测试过期
    cache.set("expire_key", &"test", Some(Duration::from_millis(1))).await.unwrap();
    tokio::time::sleep(Duration::from_millis(2)).await;
    
    let expired: Option<String> = cache.get("expire_key").await.unwrap();
    assert_eq!(expired, None);
}

fn create_test_monitoring_log(event_id: &str) -> MonitoringLogEntry {
    MonitoringLogEntry {
        id: 0,
        event_id: event_id.to_string(),
        event_type: "test_event".to_string(),
        timestamp: Utc::now(),
        adspace_id: 1,
        ad_id: Some(1),
        campaign_id: Some(1),
        user_id: Some("test_user".to_string()),
        device_info: None,
        location_info: None,
        custom_properties: None,
        processing_status: "pending".to_string(),
        created_at: Utc::now(),
        updated_at: Utc::now(),
    }
}
```

### 8.5 错误处理和日志

**项目位置**: `crates/04-core/shared/src/errors/monitoring_errors.rs`

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MonitoringDataError {
    #[error("Database connection failed: {source}")]
    DatabaseConnection {
        #[from]
        source: sea_orm::DbErr,
    },
    
    #[error("Cache operation failed: {message}")]
    CacheOperation { message: String },
    
    #[error("Serialization failed: {source}")]
    Serialization {
        #[from]
        source: serde_json::Error,
    },
    
    #[error("Validation failed: {field} - {message}")]
    Validation { field: String, message: String },
    
    #[error("Operation timeout after {timeout_seconds} seconds")]
    Timeout { timeout_seconds: u64 },
    
    #[error("Circuit breaker is open for service: {service}")]
    CircuitBreakerOpen { service: String },
    
    #[error("Concurrent modification detected: {entity_type} with id {entity_id}")]
    ConcurrentModification { entity_type: String, entity_id: String },
}

// 日志配置
use tracing::{info, warn, error, debug};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

pub fn configure_logging() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "info".into()),
        ))
        .with(tracing_subscriber::fmt::layer().json())
        .init();
        
    Ok(())
}

// 性能监控宏
#[macro_export]
macro_rules! monitor_query_performance {
    ($operation:expr, $query:block) => {{
        let start = std::time::Instant::now();
        let result = $query;
        let duration = start.elapsed();
        
        if duration > std::time::Duration::from_millis(100) {
            tracing::warn!(
                operation = %$operation,
                duration_ms = duration.as_millis(),
                "Slow query detected"
            );
        } else {
            tracing::debug!(
                operation = %$operation,
                duration_ms = duration.as_millis(),
                "Query completed"
            );
        }
        
        result
    }};
}
```

这份Rust版本的数据访问层设计文档为广告效果监测服务提供了完整的数据访问架构指导，确保开发团队能够实现高性能、内存安全、并发友好的数据访问层。所有设计都严格遵循Rust最佳实践和现代系统编程原则，充分利用Rust的所有权模型和类型系统。
