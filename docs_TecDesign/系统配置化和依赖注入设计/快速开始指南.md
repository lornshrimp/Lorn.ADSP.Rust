# 快速开始指南

## 概述

本指南将帮助您快速上手基于Rust约定的配置化和依赖注入基础设施。通过遵循预定义的约定规范，您可以实现零配置的组件开发。

**重要提醒**：在开始之前，请务必阅读并理解《统一配置化和依赖注入架构设计.md》中的约定规范章节，这是使用此基础设施的前提。

## 约定规范快速参考

### 组件命名约定

| 组件类型   | 命名格式           | 生命周期    | 配置路径                  |
| ---------- | ------------------ | ----------- | ------------------------- |
| 策略组件   | `{功能}Strategy`   | Per-Request | `strategies.{功能}`       |
| 服务组件   | `{功能}Service`    | Singleton   | `services.{功能}`         |
| 管理器组件 | `{功能}Manager`    | Singleton   | `{功能}`                  |
| 数据提供者 | `{数据源}Provider` | Scoped      | `data_providers.{数据源}` |
| 定向匹配器 | `{类型}Matcher`    | Per-Request | `targeting.{类型}`        |
| 计算器     | `{内容}Calculator` | Per-Request | `{内容}`                  |
| 处理器     | `{内容}Processor`  | Per-Request | `{内容}`                  |

### 配置结构体命名约定

- 配置结构体：`{模块名}Config`
- 自动映射：`AdEngineConfig` → `"ad_engine"` 配置节
- 策略配置：`UserInterestRecallConfig` → `"strategies.user_interest_recall"` 配置节

## 依赖crate添加

在项目的`Cargo.toml`中添加必要的依赖：

```toml
[dependencies]
# 核心依赖
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = "0.14"
anyhow = "1.0"
thiserror = "1.0"

# 依赖注入和配置管理
inventory = "0.3"
once_cell = "1.19"
parking_lot = "0.12"

# 异步运行时
futures = "0.3"
async-trait = "0.1"

# 日志和监控
tracing = "0.1"
tracing-subscriber = "0.3"

# 过程宏
proc-macro2 = "1.0"
quote = "1.0"
syn = { version = "2.0", features = ["full"] }

# 健康检查
health-check = "0.1"
```

## 1. 核心trait定义

### 配置绑定trait

```rust
// 位置：crates/04-core/shared/src/traits/configurable.rs

use async_trait::async_trait;
use serde::de::DeserializeOwned;
use std::fmt::Debug;

/// 配置绑定trait - 所有组件都应实现此trait
pub trait Configurable: Send + Sync + 'static {
    type Config: DeserializeOwned + Send + Sync + Clone + Debug + 'static;
    
    /// 获取配置路径
    fn config_path() -> &'static str;
    
    /// 加载配置
    fn load_config(config_manager: &ConfigManager) -> Result<Self::Config, ConfigError>;
    
    /// 验证配置
    fn validate_config(config: &Self::Config) -> Result<(), ValidationError> {
        // 默认实现：无验证
        Ok(())
    }
    
    /// 配置变更通知
    fn on_config_changed(&mut self, new_config: Self::Config) -> Result<(), ConfigError> {
        // 默认实现：无操作
        Ok(())
    }
}

/// 健康检查trait
#[async_trait]
pub trait HealthCheckable: Send + Sync {
    async fn check_health(&self) -> HealthStatus;
}

/// 组件注册trait
pub trait ComponentRegistrable: Send + Sync + 'static {
    fn component_name() -> &'static str;
    fn component_type() -> ComponentType;
    fn priority() -> i32 { 0 }
    fn is_enabled() -> bool { true }
}
```

### 核心枚举和错误类型

```rust
// 位置：crates/04-core/shared/src/types.rs

#[derive(Debug, Clone, PartialEq)]
pub enum ComponentType {
    Strategy,
    Service,
    Manager,
    Provider,
    Matcher,
    Calculator,
    Processor,
}

#[derive(Debug, Clone, PartialEq)]
pub enum HealthStatus {
    Healthy,
    Degraded,
    Unhealthy,
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("配置路径 '{path}' 不存在")]
    PathNotFound { path: String },
    
    #[error("配置解析失败: {reason}")]
    ParseError { reason: String },
    
    #[error("配置验证失败: {errors:?}")]
    ValidationFailed { errors: Vec<String> },
    
    #[error("配置热重载失败: {source}")]
    HotReloadFailed { source: anyhow::Error },
}

#[derive(Debug, thiserror::Error)]
pub enum ValidationError {
    #[error("字段 '{field}' 验证失败: {message}")]
    FieldValidation { field: String, message: String },
    
    #[error("范围验证失败: {message}")]
    RangeValidation { message: String },
    
    #[error("自定义验证失败: {message}")]
    CustomValidation { message: String },
}
```

## 2. 配置绑定宏实现

### 组件配置绑定宏

```rust
// 位置：crates/05-infrastructure/dependency-injection/src/macros/config_binding.rs

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemStruct, LitStr};

/// 配置绑定过程宏
/// 用法: #[config_binding("ad_engine.rtb")]
#[proc_macro_attribute]
pub fn config_binding(args: TokenStream, input: TokenStream) -> TokenStream {
    let config_path = parse_macro_input!(args as LitStr);
    let input_struct = parse_macro_input!(input as ItemStruct);
    
    let struct_name = &input_struct.ident;
    let config_path_str = config_path.value();
    
    let expanded = quote! {
        #input_struct
        
        impl crate::shared::traits::Configurable for #struct_name {
            type Config = AdEngineConfig; // 假设使用AdEngineConfig
            
            fn config_path() -> &'static str {
                #config_path_str
            }
            
            fn load_config(config_manager: &ConfigManager) -> Result<Self::Config, ConfigError> {
                config_manager.get_config(Self::config_path())
            }
        }
        
        // 自动注册到inventory系统
        inventory::submit! {
            ComponentRegistration {
                name: stringify!(#struct_name),
                config_path: #config_path_str,
                component_type: ComponentType::from_name(stringify!(#struct_name)),
                create_fn: |config_manager| {
                    let config = #struct_name::load_config(config_manager)?;
                    Ok(Box::new(#struct_name::new(config)?))
                },
            }
        }
    };
    
    TokenStream::from(expanded)
}

/// 组件注册宏
/// 用法: #[component(priority = 100, enabled = true)]
#[proc_macro_attribute]
pub fn component(args: TokenStream, input: TokenStream) -> TokenStream {
    // 解析宏参数和生成实现代码
    // 具体实现类似config_binding宏
    input // 简化示例
}
```

### 组件类型推断

```rust
// 位置：crates/05-infrastructure/dependency-injection/src/component_type.rs

impl ComponentType {
    pub fn from_name(name: &str) -> Self {
        if name.ends_with("Strategy") {
            ComponentType::Strategy
        } else if name.ends_with("Service") {
            ComponentType::Service
        } else if name.ends_with("Manager") {
            ComponentType::Manager
        } else if name.ends_with("Provider") {
            ComponentType::Provider
        } else if name.ends_with("Matcher") {
            ComponentType::Matcher
        } else if name.ends_with("Calculator") {
            ComponentType::Calculator
        } else if name.ends_with("Processor") {
            ComponentType::Processor
        } else {
            ComponentType::Service // 默认类型
        }
    }
    
    pub fn default_lifetime(&self) -> ComponentLifetime {
        match self {
            ComponentType::Strategy => ComponentLifetime::PerRequest,
            ComponentType::Service => ComponentLifetime::Singleton,
            ComponentType::Manager => ComponentLifetime::Singleton,
            ComponentType::Provider => ComponentLifetime::Scoped,
            ComponentType::Matcher => ComponentLifetime::PerRequest,
            ComponentType::Calculator => ComponentLifetime::PerRequest,
            ComponentType::Processor => ComponentLifetime::PerRequest,
        }
## 3. 配置管理基础设施

### 配置管理器实现

```rust
// 位置：crates/05-infrastructure/config/src/config_manager.rs

use serde::de::DeserializeOwned;
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::RwLock;
use config::{Config, Environment, File};

pub struct ConfigManager {
    config: Arc<RwLock<Config>>,
    watchers: Arc<RwLock<HashMap<String, Vec<ConfigWatcher>>>>,
}

impl ConfigManager {
    pub fn new() -> Result<Self, ConfigError> {
        let config = Config::builder()
            .add_source(File::with_name("config/default.toml"))
            .add_source(File::with_name("config/local.toml").required(false))
            .add_source(Environment::with_prefix("ADSP"))
            .build()?;
            
        Ok(Self {
            config: Arc::new(RwLock::new(config)),
            watchers: Arc::new(RwLock::new(HashMap::new())),
        })
    }
    
    pub fn get_config<T>(&self, path: &str) -> Result<T, ConfigError>
    where
        T: DeserializeOwned
    {
        let config = self.config.read();
        let value = config.get::<T>(path)
            .map_err(|e| ConfigError::ParseError { 
                reason: format!("Failed to parse config at path '{}': {}", path, e) 
            })?;
        Ok(value)
    }
    
    pub fn watch_config<F>(&self, path: &str, callback: F) 
    where
        F: Fn() + Send + Sync + 'static
    {
        let mut watchers = self.watchers.write();
        let path_watchers = watchers.entry(path.to_string()).or_insert_with(Vec::new);
        path_watchers.push(ConfigWatcher::new(callback));
    }
}

pub struct ConfigWatcher {
    callback: Box<dyn Fn() + Send + Sync>,
}

impl ConfigWatcher {
    pub fn new<F>(callback: F) -> Self 
    where
        F: Fn() + Send + Sync + 'static
    {
        Self {
            callback: Box::new(callback),
        }
    }
}
```

### 组件注册基础设施

```rust
// 位置：crates/05-infrastructure/dependency-injection/src/component_registry.rs

use std::collections::HashMap;
use std::sync::Arc;
use anyhow::Result;

pub struct ComponentRegistry {
    components: HashMap<String, ComponentRegistration>,
    config_manager: Arc<ConfigManager>,
}

#[derive(Clone)]
pub struct ComponentRegistration {
    pub name: &'static str,
    pub config_path: &'static str,
    pub component_type: ComponentType,
    pub create_fn: fn(&ConfigManager) -> Result<Box<dyn std::any::Any + Send + Sync>>,
}

inventory::collect!(ComponentRegistration);

impl ComponentRegistry {
    pub fn new(config_manager: Arc<ConfigManager>) -> Self {
        Self {
            components: HashMap::new(),
            config_manager,
        }
    }
    
    pub fn discover_components(&mut self) -> Result<()> {
        // 从inventory收集所有注册的组件
        for registration in inventory::iter::<ComponentRegistration> {
            self.components.insert(
                registration.name.to_string(), 
                registration.clone()
            );
        }
        Ok(())
    }
    
    pub fn create_component(&self, name: &str) -> Result<Box<dyn std::any::Any + Send + Sync>> {
        let registration = self.components.get(name)
            .ok_or_else(|| anyhow::anyhow!("Component '{}' not found", name))?;
            
        (registration.create_fn)(&self.config_manager)
    }
}
```

## 4. 标准配置文件

根据Rust生态系统约定，使用TOML格式创建配置文件：

### 主配置文件：`config/default.toml`

```toml
# 广告引擎核心配置
[ad_engine]
max_concurrent_requests = 1000
default_timeout_secs = 30
enable_performance_monitoring = true
enable_debug_logging = false

# 数据访问配置
[data_access]
default_connection_string = "postgresql://user:pass@localhost/adsp"
command_timeout_secs = 30
retry_count = 3
enable_connection_pooling = true

# 策略配置
[strategies]
[strategies.user_interest_recall]
max_candidates = 1000
cache_expiration_secs = 900  # 15分钟
score_threshold = 0.3
is_enabled = true
priority = 100

[strategies.contextual_targeting]
max_keywords = 50
score_weight = 0.8
is_enabled = true
priority = 90

[strategies.frequency_capping]
max_impressions_per_hour = 10
max_impressions_per_day = 50
is_enabled = true
priority = 80

# 数据提供者配置
[data_providers]
[data_providers.user_profile]
connection_string = "postgresql://user:pass@localhost/profiles"
command_timeout_secs = 30
cache_expiration_secs = 3600  # 1小时
is_enabled = true
retry_policy = { max_retries = 3, retry_interval_secs = 5, backoff_multiplier = 2.0 }

[data_providers.redis_cache]
connection_string = "redis://localhost:6379"
database = 0
command_timeout_secs = 5
is_enabled = true

# 定向配置
[targeting]
[targeting.geographic]
enable_city_targeting = true
enable_region_targeting = true
default_radius_km = 50
is_enabled = true

[targeting.demographic]
enable_age_targeting = true
enable_gender_targeting = true
enable_income_targeting = false
is_enabled = true

# 监控配置
[monitoring]
[monitoring.health_checks]
enabled = true
check_interval_secs = 30
failure_threshold = 3

[monitoring.metrics]
enabled = true
collection_interval_secs = 60
export_prometheus = true

# 日志配置
[logging]
level = "info"
format = "json"
file_rotation = true
max_file_size_mb = 100
```

### 环境特定配置：`config/local.toml`

```toml
# 本地开发环境配置覆盖
[ad_engine]
enable_debug_logging = true
max_concurrent_requests = 100

[data_access]
default_connection_string = "postgresql://localhost/adsp_dev"

[logging]
level = "debug"
format = "text"
```

**重要说明**：

- 配置文件按功能模块组织，使用snake_case命名
- 时间配置使用秒为单位的整数：`cache_expiration_secs = 900`
- 每个组件配置都应包含 `is_enabled`、`priority` 等通用属性
- 支持环境变量覆盖：`ADSP_AD_ENGINE__MAX_CONCURRENT_REQUESTS=2000`

## 5. 组件实现示例（遵循约定）

### 策略组件示例

```rust
// 位置：crates/03-strategies/recall/src/user_interest_recall_strategy.rs

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::time::Duration;
use tracing::{info, error};
use crate::shared::traits::{Configurable, HealthCheckable, ComponentRegistrable};
use crate::shared::types::{HealthStatus, ComponentType};

// 1. 策略组件 - 按命名约定：{功能}Strategy
#[config_binding("strategies.user_interest_recall")]
pub struct UserInterestRecallStrategy {
    config: UserInterestRecallConfig,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl UserInterestRecallStrategy {
    pub fn new(config: UserInterestRecallConfig) -> Result<Self, anyhow::Error> {
        Ok(Self {
            config,
            logger: Arc::new(TracingLogger::new()),
        })
    }
}

#[async_trait]
impl AdProcessingStrategy for UserInterestRecallStrategy {
    async fn execute_async(
        &self,
        candidates: Vec<AdCandidate>,
        context: &AdContext,
    ) -> Result<StrategyResult, StrategyError> {
        
        if !self.config.is_enabled {
            return Ok(StrategyResult::disabled());
        }

        info!(
            "Executing UserInterestRecall strategy with {} candidates",
            candidates.len()
        );

        match self.process_candidates(candidates).await {
            Ok(results) => {
                let processed_candidates: Vec<AdCandidate> = results
                    .into_iter()
                    .filter(|c| c.score >= self.config.score_threshold)
                    .take(self.config.max_candidates)
                    .collect();

                Ok(StrategyResult {
                    success: true,
                    processed_candidates,
                    execution_time: Duration::from_millis(50),
                    metadata: HashMap::new(),
                })
            }
            Err(e) => {
                error!("Failed to execute UserInterestRecall strategy: {}", e);
                Ok(StrategyResult::failed(&e.to_string()))
            }
        }
    }
}

#[async_trait]
impl HealthCheckable for UserInterestRecallStrategy {
    async fn check_health(&self) -> HealthStatus {
        // 检查配置有效性
        if self.config.max_candidates <= 0 {
            return HealthStatus::Unhealthy;
        }
        
        if self.config.score_threshold < 0.0 || self.config.score_threshold > 1.0 {
            return HealthStatus::Unhealthy;
        }
        
        HealthStatus::Healthy
    }
}

impl ComponentRegistrable for UserInterestRecallStrategy {
    fn component_name() -> &'static str {
        "UserInterestRecallStrategy"
    }
    
    fn component_type() -> ComponentType {
        ComponentType::Strategy
    }
    
    fn priority() -> i32 {
        100
    }
}

// 处理候选广告的私有方法
impl UserInterestRecallStrategy {
    async fn process_candidates(&self, candidates: Vec<AdCandidate>) -> Result<Vec<AdCandidate>, anyhow::Error> {
        // 实现用户兴趣召回逻辑
        // 这里是示例实现，实际应根据用户兴趣数据进行处理
        
        tokio::time::sleep(Duration::from_millis(10)).await; // 模拟异步处理
        
        let mut processed = candidates;
        processed.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
        
        Ok(processed)
    }
}

// 2. 配置结构体 - 按命名约定：{模块名}Config
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserInterestRecallConfig {
    pub max_candidates: usize,
    pub score_threshold: f64,
    pub cache_expiration_secs: u64,
    pub is_enabled: bool,
    pub priority: i32,
}

impl Default for UserInterestRecallConfig {
    fn default() -> Self {
        Self {
            max_candidates: 1000,
            score_threshold: 0.3,
            cache_expiration_secs: 900, // 15分钟
            is_enabled: true,
            priority: 100,
        }
    }
}

// 3. 配置验证实现
impl UserInterestRecallConfig {
    pub fn validate(&self) -> Result<(), ValidationError> {
        if self.max_candidates == 0 {
            return Err(ValidationError::FieldValidation {
                field: "max_candidates".to_string(),
                message: "MaxCandidates must be greater than 0".to_string(),
            });
        }

        if self.score_threshold < 0.0 || self.score_threshold > 1.0 {
            return Err(ValidationError::RangeValidation {
                message: "ScoreThreshold must be between 0 and 1".to_string(),
            });
        }

        if self.cache_expiration_secs == 0 {
            return Err(ValidationError::FieldValidation {
                field: "cache_expiration_secs".to_string(),
                message: "CacheExpiration must be positive".to_string(),
            });
        }

        Ok(())
    }
}

// 实现Configurable trait
impl Configurable for UserInterestRecallStrategy {
    type Config = UserInterestRecallConfig;
    
    fn config_path() -> &'static str {
        "strategies.user_interest_recall"
    }
    
    fn load_config(config_manager: &ConfigManager) -> Result<Self::Config, ConfigError> {
        let config: Self::Config = config_manager.get_config(Self::config_path())?;
        config.validate().map_err(|e| ConfigError::ValidationFailed { 
            errors: vec![e.to_string()] 
        })?;
        Ok(config)
    }
    
    fn validate_config(config: &Self::Config) -> Result<(), ValidationError> {
        config.validate()
    }
}
```

### 数据提供者组件示例

```rust
// 位置：crates/05-infrastructure/data-providers/src/redis_user_provider.rs

use async_trait::async_trait;
use redis::{AsyncCommands, Client};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

// 数据提供者 - 按命名约定：{数据源}Provider
#[config_binding("data_providers.redis_user")]
pub struct RedisUserProvider {
    config: RedisUserProviderConfig,
    client: Arc<RwLock<Option<Client>>>,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl RedisUserProvider {
    pub fn new(config: RedisUserProviderConfig) -> Result<Self, anyhow::Error> {
        let client = Client::open(config.connection_string.as_str())?;
        
        Ok(Self {
            config,
            client: Arc::new(RwLock::new(Some(client))),
            logger: Arc::new(TracingLogger::new()),
        })
    }
}

#[async_trait]
impl DataAccessProvider for RedisUserProvider {
    async fn get_user_profile(
        &self, 
        user_id: &str
    ) -> Result<Option<UserProfile>, DataAccessError> {
        
        if !self.config.is_enabled {
            return Ok(None);
        }

        let client_guard = self.client.read().await;
        let client = client_guard.as_ref()
            .ok_or_else(|| DataAccessError::ConnectionFailed)?;
            
        let mut connection = client.get_async_connection().await
            .map_err(|e| DataAccessError::ConnectionFailed)?;

        let cache_key = format!("user:profile:{}", user_id);
        
        match connection.get::<_, Option<String>>(&cache_key).await {
            Ok(Some(cached_data)) => {
                match serde_json::from_str::<UserProfile>(&cached_data) {
                    Ok(profile) => Ok(Some(profile)),
                    Err(e) => {
                        error!("Failed to deserialize user profile: {}", e);
                        Ok(None)
                    }
                }
            }
            Ok(None) => {
                // 缓存未命中，可以实现从其他数据源加载的逻辑
                Ok(None)
            }
            Err(e) => {
                error!("Redis query failed for user {}: {}", user_id, e);
                Err(DataAccessError::QueryFailed { 
                    reason: e.to_string() 
                })
            }
        }
    }
}

#[async_trait]
impl HealthCheckable for RedisUserProvider {
    async fn check_health(&self) -> HealthStatus {
        if !self.config.is_enabled {
            return HealthStatus::Healthy;
        }

        let client_guard = self.client.read().await;
        let client = match client_guard.as_ref() {
            Some(client) => client,
            None => return HealthStatus::Unhealthy,
        };

        match client.get_async_connection().await {
            Ok(mut connection) => {
                match redis::cmd("PING").query_async::<_, String>(&mut connection).await {
                    Ok(_) => HealthStatus::Healthy,
                    Err(_) => HealthStatus::Unhealthy,
                }
            }
            Err(_) => HealthStatus::Unhealthy,
        }
    }
}

// 数据提供者配置结构体
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RedisUserProviderConfig {
    pub connection_string: String,
    pub database: u8,
    pub command_timeout_secs: u64,
    pub is_enabled: bool,
}

impl Default for RedisUserProviderConfig {
    fn default() -> Self {
        Self {
            connection_string: "redis://localhost:6379".to_string(),
            database: 0,
            command_timeout_secs: 5,
            is_enabled: true,
        }
    }
}

impl Configurable for RedisUserProvider {
    type Config = RedisUserProviderConfig;
    
    fn config_path() -> &'static str {
        "data_providers.redis_user"
    }
    
    fn load_config(config_manager: &ConfigManager) -> Result<Self::Config, ConfigError> {
        config_manager.get_config(Self::config_path())
    }
}
```

### 服务组件示例

```rust
// 位置：crates/02-services/analytics/src/metrics_collection_service.rs

use async_trait::async_trait;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;

// 服务组件 - 按命名约定：{功能}Service，自动注册为单例
#[config_binding("services.metrics_collection")]
pub struct MetricsCollectionService {
    config: MetricsCollectionConfig,
    metrics_buffer: Arc<RwLock<Vec<AdRequestMetrics>>>,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl MetricsCollectionService {
    pub fn new(config: MetricsCollectionConfig) -> Result<Self, anyhow::Error> {
        Ok(Self {
            config,
            metrics_buffer: Arc::new(RwLock::new(Vec::new())),
            logger: Arc::new(TracingLogger::new()),
        })
    }
    
    pub async fn record_ad_request(&self, metrics: AdRequestMetrics) {
        if !self.config.is_enabled {
            return;
        }

        let mut buffer = self.metrics_buffer.write().await;
        buffer.push(metrics);
        
        // 如果缓冲区满了，触发导出
        if buffer.len() >= self.config.max_buffer_size {
            self.export_metrics(&buffer).await;
            buffer.clear();
        }
    }
    
    async fn export_metrics(&self, metrics: &[AdRequestMetrics]) {
        // 实现指标导出逻辑
        info!("Exporting {} metrics", metrics.len());
        
        // 这里可以导出到Prometheus、InfluxDB等
        for metric in metrics {
            debug!("Metric: {:?}", metric);
        }
    }
}

#[async_trait]
impl HealthCheckable for MetricsCollectionService {
    async fn check_health(&self) -> HealthStatus {
        if !self.config.is_enabled {
            return HealthStatus::Healthy;
        }
        
        let buffer = self.metrics_buffer.read().await;
        if buffer.len() > self.config.max_buffer_size * 2 {
            // 缓冲区过满，可能存在问题
            HealthStatus::Degraded
        } else {
            HealthStatus::Healthy
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsCollectionConfig {
    pub is_enabled: bool,
    pub collection_interval_secs: u64,
    pub max_buffer_size: usize,
    pub export_prometheus: bool,
}

impl Default for MetricsCollectionConfig {
    fn default() -> Self {
        Self {
            is_enabled: true,
            collection_interval_secs: 60,
            max_buffer_size: 10000,
            export_prometheus: true,
        }
    }
}

impl Configurable for MetricsCollectionService {
    type Config = MetricsCollectionConfig;
    
    fn config_path() -> &'static str {
        "services.metrics_collection"
    }
    
    fn load_config(config_manager: &ConfigManager) -> Result<Self::Config, ConfigError> {
        config_manager.get_config(Self::config_path())
    }
}

// 组件自动注册（通过宏生成）
impl ComponentRegistrable for MetricsCollectionService {
    fn component_name() -> &'static str {
        "MetricsCollectionService"
    }
    
    fn component_type() -> ComponentType {
        ComponentType::Service
    }
}
## 6. 应用程序启动配置

### 主程序入口

```rust
// 位置：crates/02-services/ad-engine/src/main.rs

use anyhow::Result;
use tokio;
use tracing::{info, error};
use std::sync::Arc;

use crate::infrastructure::{ConfigManager, ComponentRegistry};
use crate::shared::types::HealthStatus;

#[tokio::main]
async fn main() -> Result<()> {
    // 初始化日志
    tracing_subscriber::fmt::init();
    
    // 创建并启动应用
    let app = AdSystemApplication::new().await?;
    
    // 验证配置和组件
    validate_configuration(&app).await?;
    
    // 启动应用
    app.run().await?;
    
    Ok(())
}

pub struct AdSystemApplication {
    config_manager: Arc<ConfigManager>,
    component_registry: ComponentRegistry,
}

impl AdSystemApplication {
    pub async fn new() -> Result<Self> {
        // 1. 初始化配置管理器
        let config_manager = Arc::new(ConfigManager::new()?);
        
        // 2. 创建组件注册表
        let mut component_registry = ComponentRegistry::new(config_manager.clone());
        
        // 3. 自动发现和注册所有组件
        component_registry.discover_components()?;
        
        Ok(Self {
            config_manager,
            component_registry,
        })
    }
    
    pub async fn run(&self) -> Result<()> {
        info!("Starting Lorn.ADSP-Rust Application");
        
        // 启动所有组件
        self.start_all_components().await?;
        
        // 等待关闭信号
        tokio::signal::ctrl_c().await?;
        
        info!("Shutting down gracefully");
        self.shutdown_all_components().await?;
        
        Ok(())
    }
    
    async fn start_all_components(&self) -> Result<()> {
        // 按优先级顺序启动组件
        let component_names: Vec<String> = self.component_registry
            .get_component_names()
            .into_iter()
            .collect();
            
        for name in component_names {
            match self.component_registry.create_component(&name) {
                Ok(component) => {
                    info!("Successfully started component: {}", name);
                }
                Err(e) => {
                    error!("Failed to start component {}: {}", name, e);
                    return Err(e);
                }
            }
        }
        
        Ok(())
    }
    
    async fn shutdown_all_components(&self) -> Result<()> {
        // 实现优雅关闭逻辑
        info!("All components shut down successfully");
        Ok(())
    }
}

// 启动时验证配置和组件（推荐）
async fn validate_configuration(app: &AdSystemApplication) -> Result<()> {
    info!("Validating application configuration...");
    
    // 验证核心配置能正常加载
    let ad_engine_config: AdEngineConfig = app.config_manager
        .get_config("ad_engine")?;
    info!("✓ AdEngine configuration loaded successfully");
    
    // 验证策略组件
    let strategy_count = app.component_registry
        .get_components_by_type(ComponentType::Strategy)
        .len();
    info!("✓ Found {} strategy components", strategy_count);
    
    // 验证数据提供者
    let provider_count = app.component_registry
        .get_components_by_type(ComponentType::Provider)
        .len();
    info!("✓ Found {} data provider components", provider_count);
    
    // 运行健康检查
    let health_checks = app.component_registry.get_health_checkable_components();
    for (name, component) in health_checks {
        match component.check_health().await {
            HealthStatus::Healthy => {
                info!("✓ Component {} health check: Healthy", name);
            }
            HealthStatus::Degraded => {
                info!("⚠ Component {} health check: Degraded", name);
            }
            HealthStatus::Unhealthy => {
                error!("✗ Component {} health check: Unhealthy", name);
                return Err(anyhow::anyhow!("Component {} is unhealthy", name));
            }
        }
    }
    
    info!("✓ All configuration validation checks passed");
    Ok(())
}
```

### 核心配置结构体定义

```rust
// 位置：crates/04-core/shared/src/config/mod.rs

use serde::{Deserialize, Serialize};
use std::time::Duration;

// 广告引擎核心配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdEngineConfig {
    pub max_concurrent_requests: usize,
    pub default_timeout_secs: u64,
    pub enable_performance_monitoring: bool,
    pub enable_debug_logging: bool,
}

impl Default for AdEngineConfig {
    fn default() -> Self {
        Self {
            max_concurrent_requests: 1000,
            default_timeout_secs: 30,
            enable_performance_monitoring: true,
            enable_debug_logging: false,
        }
    }
}

// 数据访问配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataAccessConfig {
    pub default_connection_string: String,
    pub command_timeout_secs: u64,
    pub retry_count: u32,
    pub enable_connection_pooling: bool,
}

impl Default for DataAccessConfig {
    fn default() -> Self {
        Self {
            default_connection_string: "postgresql://localhost/adsp".to_string(),
            command_timeout_secs: 30,
            retry_count: 3,
            enable_connection_pooling: true,
        }
    }
}

// 监控配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub health_checks: HealthCheckConfig,
    pub metrics: MetricsConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheckConfig {
    pub enabled: bool,
    pub check_interval_secs: u64,
    pub failure_threshold: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsConfig {
    pub enabled: bool,
    pub collection_interval_secs: u64,
    pub export_prometheus: bool,
}
## 7. 业务代码使用示例

### 广告引擎核心实现

```rust
// 位置：crates/02-services/ad-engine/src/ad_engine.rs

use async_trait::async_trait;
use std::sync::Arc;
use std::collections::HashMap;
use tracing::{info, debug, error};

pub struct AdEngine {
    strategies: Vec<Arc<dyn AdProcessingStrategy + Send + Sync>>,
    config: Arc<AdEngineConfig>,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl AdEngine {
    pub fn new(
        strategies: Vec<Arc<dyn AdProcessingStrategy + Send + Sync>>,
        config: Arc<AdEngineConfig>
    ) -> Self {
        // 按优先级排序策略
        let mut sorted_strategies = strategies;
        sorted_strategies.sort_by(|a, b| {
            b.get_priority().cmp(&a.get_priority())
        });
        
        Self {
            strategies: sorted_strategies,
            config,
            logger: Arc::new(TracingLogger::new()),
        }
    }
}

#[async_trait]
impl AdProcessingEngine for AdEngine {
    async fn process_request(&self, request: AdRequest) -> Result<AdResponse, AdEngineError> {
        let context = AdContext::new(request.clone());
        let mut candidates = self.get_initial_candidates(&request).await?;

        info!(
            "Processing ad request {} with {} strategies", 
            request.id, 
            self.strategies.len()
        );

        // 依次执行所有启用的策略
        for strategy in &self.strategies {
            let strategy_name = strategy.component_name();
            
            match strategy.execute_async(candidates.clone(), &context).await {
                Ok(result) => {
                    if result.success && !result.processed_candidates.is_empty() {
                        candidates = result.processed_candidates;
                        debug!(
                            "Strategy {} processed {} candidates in {:?}",
                            strategy_name, 
                            candidates.len(),
                            result.execution_time
                        );
                    }
                }
                Err(e) => {
                    error!(
                        "Strategy {} execution failed: {}",
                        strategy_name, 
                        e
                    );
                    // 策略失败不影响整体流程，继续下一个策略
                    continue;
                }
            }
        }

        let final_ads: Vec<Ad> = candidates
            .into_iter()
            .take(request.max_ads)
            .map(|candidate| candidate.into_ad())
            .collect();

        Ok(AdResponse {
            request_id: request.id,
            ads: final_ads,
            processed_at: chrono::Utc::now(),
            processing_time: context.get_elapsed_time(),
        })
    }
    
    async fn get_initial_candidates(&self, request: &AdRequest) -> Result<Vec<AdCandidate>, AdEngineError> {
        // 获取初始候选广告的逻辑
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await; // 模拟异步操作
        
        Ok(vec![
            AdCandidate { id: "ad1".to_string(), score: 0.8, metadata: HashMap::new() },
            AdCandidate { id: "ad2".to_string(), score: 0.6, metadata: HashMap::new() },
            AdCandidate { id: "ad3".to_string(), score: 0.4, metadata: HashMap::new() },
        ])
    }
}

// 扩展trait方法，获取策略优先级
trait StrategyPriority {
    fn get_priority(&self) -> i32;
}

impl<T: ComponentRegistrable> StrategyPriority for T {
    fn get_priority(&self) -> i32 {
        T::priority()
    }
}
```

### 依赖注入集成

```rust
// 位置：crates/05-infrastructure/dependency-injection/src/container.rs

use std::sync::Arc;
use std::collections::HashMap;

pub struct ServiceContainer {
    strategies: Vec<Arc<dyn AdProcessingStrategy + Send + Sync>>,
    providers: HashMap<String, Arc<dyn DataAccessProvider + Send + Sync>>,
    services: HashMap<String, Arc<dyn std::any::Any + Send + Sync>>,
    config_manager: Arc<ConfigManager>,
}

impl ServiceContainer {
    pub fn new(config_manager: Arc<ConfigManager>) -> Self {
        Self {
            strategies: Vec::new(),
            providers: HashMap::new(),
            services: HashMap::new(),
            config_manager,
        }
    }
    
    // 构建完整的广告引擎实例
    pub fn build_ad_engine(&self) -> Result<AdEngine, anyhow::Error> {
        let ad_engine_config: AdEngineConfig = self.config_manager
            .get_config("ad_engine")?;
        
        let engine = AdEngine::new(
            self.strategies.clone(),
            Arc::new(ad_engine_config)
        );
        
        Ok(engine)
    }
    
    // 注册策略组件
    pub fn register_strategy<T>(&mut self, strategy: T) -> Result<(), anyhow::Error>
    where
        T: AdProcessingStrategy + ComponentRegistrable + Send + Sync + 'static
    {
        self.strategies.push(Arc::new(strategy));
        Ok(())
    }
    
    // 注册数据提供者
    pub fn register_provider<T>(&mut self, name: &str, provider: T) -> Result<(), anyhow::Error>
    where
        T: DataAccessProvider + Send + Sync + 'static
    {
        self.providers.insert(name.to_string(), Arc::new(provider));
        Ok(())
    }
    
    // 自动注册所有发现的组件
    pub fn auto_register_components(&mut self) -> Result<(), anyhow::Error> {
        // 从inventory收集所有组件注册信息
        for registration in inventory::iter::<ComponentRegistration> {
            match registration.component_type {
                ComponentType::Strategy => {
                    let component = (registration.create_fn)(&self.config_manager)?;
                    // 类型转换和注册逻辑
                }
                ComponentType::Provider => {
                    let component = (registration.create_fn)(&self.config_manager)?;
                    // 类型转换和注册逻辑
                }
                _ => {
                    // 处理其他组件类型
                }
            }
        }
        
        Ok(())
    }
}
```
}

## 8. 关键优势总结

### 1. 零配置开发体验

- **添加新策略**：创建 `{功能}Strategy` 结构体 → 使用 `#[config_binding]` 宏 → 自动发现和注册
- **添加新配置**：创建 `{模块}Config` 结构体 → 自动绑定TOML配置节
- **修改配置**：编辑TOML配置文件 → 自动热重载
- **健康检查**：实现 `HealthCheckable` trait → 自动添加监控

### 2. 标准化Rust开发模式

- **命名约定**：统一的组件命名规范，符合Rust生态习惯
- **配置约定**：标准化的TOML配置文件结构，降低学习成本
- **生命周期约定**：自动推断组件生命周期，减少配置错误
- **验证约定**：统一的配置验证机制，提高系统稳定性

### 3. 生产就绪特性

- **基于Rust生态**：使用成熟的Rust crate，内存安全可靠
- **配置热重载**：支持运行时配置更新，无需重启
- **健康检查**：完整的组件健康监控体系
- **错误处理**：优雅的错误处理和降级机制

## 9. 常见问题

### Q: 如果我的组件不符合命名约定怎么办？

A: 可以使用宏显式标记：

```rust
#[config_binding("custom_path.my_component")]
#[component(priority = 100, enabled = true)]
pub struct MySpecialComponent {
    config: MyConfig,
}

// 会被自动发现并注册，配置绑定到 "custom_path.my_component"
```

### Q: 如何禁用某个策略？

A: 在TOML配置文件中设置 `is_enabled = false`：

```toml
[strategies.user_interest_recall]
is_enabled = false
max_candidates = 1000
score_threshold = 0.3
```

### Q: 如何调整策略执行顺序？

A: 通过配置文件中的 `priority` 属性：

```toml
[strategies.high_priority_strategy]
priority = 100
is_enabled = true

[strategies.low_priority_strategy]
priority = 50
is_enabled = true
```

### Q: 如何添加自定义验证？

A: 在配置结构体中实现验证方法：

```rust
impl MyConfig {
    pub fn validate(&self) -> Result<(), ValidationError> {
        if self.max_retries > 10 {
            return Err(ValidationError::RangeValidation {
                message: "max_retries cannot exceed 10".to_string(),
            });
        }
        
        if self.timeout_secs == 0 {
            return Err(ValidationError::FieldValidation {
                field: "timeout_secs".to_string(),
                message: "timeout must be greater than 0".to_string(),
            });
        }
        
        Ok(())
    }
}
```

## 10. 配置属性使用详解

### 基本模式：直接使用配置属性

```rust
// 策略组件示例
#[config_binding("strategies.user_interest_recall")]
pub struct UserInterestRecallStrategy {
    config: UserInterestRecallConfig,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl UserInterestRecallStrategy {
    pub fn new(config: UserInterestRecallConfig) -> Result<Self, anyhow::Error> {
        // 验证配置
        config.validate()?;
        
        Ok(Self {
            config,
            logger: Arc::new(TracingLogger::new()),
        })
    }
}

#[async_trait]
impl AdProcessingStrategy for UserInterestRecallStrategy {
    async fn execute_async(
        &self,
        candidates: Vec<AdCandidate>,
        context: &AdContext,
    ) -> Result<StrategyResult, StrategyError> {
        
        // 第1步：检查组件是否启用
        if !self.config.is_enabled {
            debug!("Strategy {} is disabled", Self::component_name());
            return Ok(StrategyResult::disabled());
        }

        // 第2步：使用配置值进行业务逻辑处理
        let filtered_candidates: Vec<AdCandidate> = candidates
            .into_iter()
            .filter(|candidate| candidate.score >= self.config.score_threshold) // 使用分数阈值配置
            .take(self.config.max_candidates) // 使用最大候选数配置
            .collect();

        info!(
            "Filtered {} candidates from {} using threshold {}",
            filtered_candidates.len(), 
            candidates.len(), 
            self.config.score_threshold
        );

        Ok(StrategyResult {
            success: true,
            processed_candidates: filtered_candidates,
            priority: self.config.priority, // 使用优先级配置
            execution_time: Duration::from_millis(50),
            metadata: HashMap::new(),
        })
    }
}

// 配置结构体 - 定义可配置的属性
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserInterestRecallConfig {
    // 从配置文件的 max_candidates = 500 自动映射
    pub max_candidates: usize,
    
    // 从配置文件的 score_threshold = 0.5 自动映射
    pub score_threshold: f64,
    
    // 从配置文件的 cache_expiration_secs = 1800 自动映射
    pub cache_expiration_secs: u64,
    
    // 从配置文件的 is_enabled = false 自动映射
    pub is_enabled: bool,
    
    // 从配置文件的 priority = 200 自动映射
    pub priority: i32,
}
```

### 对应的TOML配置文件设置

```toml
[strategies.user_interest_recall]
max_candidates = 500           # 映射到 max_candidates 属性
score_threshold = 0.5          # 映射到 score_threshold 属性
cache_expiration_secs = 1800   # 映射到 cache_expiration_secs 属性（30分钟）
is_enabled = true              # 映射到 is_enabled 属性
priority = 200                 # 映射到 priority 属性
```

### 高级配置使用模式

#### 数据提供者中的配置使用

```rust
#[config_binding("data_providers.postgresql_ad")]
pub struct PostgreSQLAdProvider {
    config: PostgreSQLAdProviderConfig,
    pool: Arc<deadpool_postgres::Pool>,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl PostgreSQLAdProvider {
    pub async fn new(config: PostgreSQLAdProviderConfig) -> Result<Self, anyhow::Error> {
        // 使用配置创建连接池
        let pool_config = deadpool_postgres::Config::from_url(&config.connection_string)?;
        let pool = pool_config.create_pool(
            Some(deadpool_postgres::Runtime::Tokio1),
            tokio_postgres::NoTls,
        )?;
        
        Ok(Self {
            config,
            pool: Arc::new(pool),
            logger: Arc::new(TracingLogger::new()),
        })
    }
}

#[async_trait]
impl DataAccessProvider for PostgreSQLAdProvider {
    async fn get_candidates(&self, request: &AdRequest) -> Result<Vec<AdCandidate>, DataAccessError> {
        if !self.config.is_enabled {
            return Ok(Vec::new());
        }

        // 使用配置的超时时间
        let timeout = Duration::from_secs(self.config.command_timeout_secs);
        
        // 使用配置的重试机制
        let mut retry_count = 0;
        let max_retries = self.config.max_retries;
        
        while retry_count <= max_retries {
            match self.execute_query_with_timeout(request, timeout).await {
                Ok(candidates) => return Ok(candidates),
                Err(e) if retry_count < max_retries => {
                    warn!(
                        "Query failed (attempt {}/{}): {}. Retrying in {} seconds...",
                        retry_count + 1,
                        max_retries + 1,
                        e,
                        self.config.retry_interval_secs
                    );
                    
                    tokio::time::sleep(Duration::from_secs(self.config.retry_interval_secs)).await;
                    retry_count += 1;
                }
                Err(e) => return Err(DataAccessError::QueryFailed { reason: e.to_string() }),
            }
        }
        
        Ok(Vec::new())
    }
    
    async fn execute_query_with_timeout(
        &self,
        request: &AdRequest,
        timeout: Duration,
    ) -> Result<Vec<AdCandidate>, anyhow::Error> {
        let client = self.pool.get().await?;
        
        let query_future = async {
            let stmt = client.prepare("SELECT * FROM ads WHERE category = $1").await?;
            let rows = client.query(&stmt, &[&request.category]).await?;
            
            let mut candidates = Vec::new();
            for row in rows {
                candidates.push(AdCandidate {
                    id: row.get("id"),
                    score: row.get("score"),
                    metadata: HashMap::new(),
                });
            }
            
            Ok(candidates)
        };
        
        tokio::time::timeout(timeout, query_future).await?
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostgreSQLAdProviderConfig {
    // 数据库连接字符串配置
    pub connection_string: String,
    
    // 命令超时时间配置（秒）
    pub command_timeout_secs: u64,
    
    // 重试次数配置
    pub max_retries: u32,
    
    // 重试间隔配置（秒）
    pub retry_interval_secs: u64,
    
    // 组件启用状态配置
    pub is_enabled: bool,
}

impl Default for PostgreSQLAdProviderConfig {
    fn default() -> Self {
        Self {
            connection_string: "postgresql://localhost/adsp".to_string(),
            command_timeout_secs: 30,
            max_retries: 3,
            retry_interval_secs: 5,
            is_enabled: true,
        }
    }
}
```

### 配置热重载实现

#### 支持配置热重载的组件

```rust
pub struct CacheService {
    config: Arc<RwLock<CacheServiceConfig>>,
    cache: Arc<RwLock<Option<moka::future::Cache<String, Value>>>>,
    config_watcher: ConfigWatcher,
    logger: Arc<dyn Logger + Send + Sync>,
}

impl CacheService {
    pub async fn new(
        config: CacheServiceConfig,
        config_manager: Arc<ConfigManager>
    ) -> Result<Self, anyhow::Error> {
        let cache = Self::create_cache(&config);
        let config = Arc::new(RwLock::new(config));
        
        let service = Self {
            config: config.clone(),
            cache: Arc::new(RwLock::new(Some(cache))),
            config_watcher: ConfigWatcher::new(),
            logger: Arc::new(TracingLogger::new()),
        };
        
        // 设置配置变更监听
        let cache_clone = service.cache.clone();
        let config_clone = config.clone();
        let logger_clone = service.logger.clone();
        
        config_manager.watch_config("services.cache", move || {
            tokio::spawn(async move {
                Self::on_configuration_changed(
                    cache_clone.clone(),
                    config_clone.clone(),
                    logger_clone.clone()
                ).await;
            });
        });
        
        Ok(service)
    }
    
    async fn on_configuration_changed(
        cache: Arc<RwLock<Option<moka::future::Cache<String, Value>>>>,
        config: Arc<RwLock<CacheServiceConfig>>,
        logger: Arc<dyn Logger + Send + Sync>,
    ) {
        info!("Cache configuration changed, reinitializing cache");
        
        // 读取新配置
        let new_config = config.read().clone();
        
        // 重新创建缓存
        let new_cache = Self::create_cache(&new_config);
        
        // 替换缓存实例
        {
            let mut cache_guard = cache.write();
            *cache_guard = Some(new_cache);
        }
        
        info!("Cache reinitialized with new configuration");
    }
    
    fn create_cache(config: &CacheServiceConfig) -> moka::future::Cache<String, Value> {
        moka::future::Cache::builder()
            .max_capacity(config.max_cache_size)
            .time_to_live(Duration::from_secs(config.default_expiration_secs))
            .build()
    }
    
    pub async fn set(&self, key: String, value: Value) {
        if let Some(cache) = self.cache.read().as_ref() {
            cache.insert(key, value).await;
        }
    }
    
    pub async fn get(&self, key: &str) -> Option<Value> {
        if let Some(cache) = self.cache.read().as_ref() {
            cache.get(key).await
        } else {
            None
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheServiceConfig {
    pub max_cache_size: u64,
    pub default_expiration_secs: u64,
    pub is_enabled: bool,
}

impl Default for CacheServiceConfig {
    fn default() -> Self {
        Self {
            max_cache_size: 1000,
            default_expiration_secs: 1800, // 30 minutes
            is_enabled: true,
        }
    }
}
```

## 11. 扩展建议

当系统需要更高级功能时，可以逐步添加：

- **分布式配置**：etcd、Consul 等配置中心集成
- **高级监控**：Prometheus、Grafana、Jaeger 分布式追踪
- **缓存策略**：Redis、Memcached 等外部缓存
- **消息队列**：RabbitMQ、Apache Kafka、NATS 等
- **服务发现**：Consul、etcd 等服务注册与发现
- **负载均衡**：基于Tower中间件的负载均衡策略

这个基于Rust的基础设施为这些高级功能提供了良好的扩展基础，充分利用了Rust的内存安全、零成本抽象和高性能特性。