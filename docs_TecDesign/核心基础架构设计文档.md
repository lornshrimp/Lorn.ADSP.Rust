# æ ¸å¿ƒåŸºç¡€æ¶æ„è®¾è®¡æ–‡æ¡£

## æ¦‚è¿°

æ ¸å¿ƒåŸºç¡€æ¶æ„æ˜¯Lorn.ADSPå¹¿å‘ŠæŠ•æ”¾ç³»ç»Ÿçš„æŠ€æœ¯åº•åº§ï¼ŒåŸºäºRust 1.75+æŠ€æœ¯æ ˆï¼Œé‡‡ç”¨é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰åŸåˆ™ã€‚æœ¬è®¾è®¡æ–‡æ¡£åŸºäºå·²æœ‰çš„åŸºç¡€è®¾æ–½å®ç°ï¼ˆ`crates/05-infrastructure`ï¼‰ï¼Œé‡ç‚¹å…³æ³¨æ‰©å±•å’Œä¼˜åŒ–ç°æœ‰æ¶æ„ï¼Œé¿å…é‡å¤é€ è½®å­ï¼Œå……åˆ†åˆ©ç”¨å·²å®ç°çš„é…ç½®ç®¡ç†ã€ä¾èµ–æ³¨å…¥ã€ç»„ä»¶å‘ç°ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

## ç°æœ‰åŸºç¡€è®¾æ–½åˆ†æ

### å·²å®ç°çš„æ ¸å¿ƒç»„ä»¶

åŸºäºå¯¹ `crates/05-infrastructure` çš„åˆ†æï¼Œä»¥ä¸‹ç»„ä»¶å·²ç»å®ç°ï¼š

#### 1. åŸºç¡€è®¾æ–½ç»„åˆå±‚ (`composition`)
- âœ… `AdSystemInfrastructure` - ç³»ç»Ÿä¸»å…¥å£
- âœ… `InfrastructureBuilder` - æ„å»ºå™¨æ¨¡å¼
- âœ… `ComponentScannerImpl` - ç»„ä»¶æ‰«æå™¨
- âœ… `ConfigSourceManager` - é…ç½®æºç®¡ç†

#### 2. é…ç½®ç®¡ç† (`config-abstractions` + `config-impl`)
- âœ… `ConfigProvider` trait - é…ç½®æä¾›è€…æŠ½è±¡
- âœ… `AdSystemConfigManager` - é…ç½®ç®¡ç†å™¨
- âœ… `TomlConfigProvider` - TOMLé…ç½®æ”¯æŒ
- âœ… `JsonConfigProvider` - JSONé…ç½®æ”¯æŒ
- âœ… `EnvironmentConfigProvider` - ç¯å¢ƒå˜é‡æ”¯æŒ

#### 3. ä¾èµ–æ³¨å…¥ (`di-abstractions` + `di-impl`)
- âœ… `ComponentRegistry` trait - ç»„ä»¶æ³¨å†Œè¡¨
- âœ… `DiContainerImpl` - ä¾èµ–æ³¨å…¥å®¹å™¨
- âœ… `ComponentScanner` - ç»„ä»¶æ‰«æ
- âœ… ç”Ÿå‘½å‘¨æœŸç®¡ç† (Singleton, Scoped, Transient)

#### 4. å…¬å…±åŸºç¡€è®¾æ–½ (`common`)
- âœ… `Component` trait - ç»„ä»¶åŸºç¡€æ¥å£
- âœ… `Configurable` trait - å¯é…ç½®ç»„ä»¶
- âœ… `HealthCheckable` trait - å¥åº·æ£€æŸ¥
- âœ… `ComponentConventions` - çº¦å®šè§„èŒƒ

## ä¼˜åŒ–æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```mermaid
graph TB
    subgraph "åº”ç”¨ç¨‹åºå±‚"
        App[åº”ç”¨ç¨‹åºå…¥å£]
        Services[ä¸šåŠ¡æœåŠ¡å±‚]
    end
    
    subgraph "å·²å®ç°çš„åŸºç¡€è®¾æ–½ç»„åˆå±‚"
        Comp[infrastructure-composition âœ…]
        Boot[InfrastructureBuilder âœ…]
        Scanner[ComponentScanner âœ…]
    end
    
    subgraph "å·²å®ç°çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½å±‚"
        Config[config-abstractions âœ…]
        DI[di-abstractions âœ…]
        Common[infrastructure-common âœ…]
    end
    
    subgraph "å·²å®ç°çš„å®ç°å±‚"
        ConfigImpl[config-impl âœ…]
        DIImpl[di-impl âœ…]
    end
    
    subgraph "éœ€è¦æ‰©å±•çš„å±‚"
        Data[data-abstractions ğŸ”„]
        Cache[caching-abstractions ğŸ”„]
        Workflow[workflow-abstractions ğŸ”„]
        Monitor[monitoring ğŸ†•]
        Security[security ğŸ†•]
    end
    
    App --> Comp
    Services --> Comp
    Comp --> Boot
    Boot --> Config
    Boot --> DI
    Boot --> Common
    
    Config --> ConfigImpl
    DI --> DIImpl
    
    Comp -.-> Data
    Comp -.-> Cache
    Comp -.-> Workflow
    Comp -.-> Monitor
    Comp -.-> Security
```

### ç°æœ‰å·¥ä½œç©ºé—´ç»“æ„

```text
crates/05-infrastructure/
â”œâ”€â”€ common/                    âœ… å·²å®ç° - å…¬å…±åŸºç¡€è®¾æ–½
â”œâ”€â”€ composition/               âœ… å·²å®ç° - åŸºç¡€è®¾æ–½ç»„åˆå±‚
â”œâ”€â”€ config-abstractions/       âœ… å·²å®ç° - é…ç½®ç®¡ç†æŠ½è±¡
â”œâ”€â”€ config-impl/              âœ… å·²å®ç° - é…ç½®ç®¡ç†å®ç°
â”œâ”€â”€ di-abstractions/          âœ… å·²å®ç° - ä¾èµ–æ³¨å…¥æŠ½è±¡
â””â”€â”€ di-impl/                  âœ… å·²å®ç° - ä¾èµ–æ³¨å…¥å®ç°
```

## åŸºäºç°æœ‰åŸºç¡€è®¾æ–½çš„æ‰©å±•è®¾è®¡

### 1. åˆ©ç”¨ç°æœ‰ç»„ä»¶å‘ç°æœºåˆ¶

#### ç°æœ‰èƒ½åŠ›åˆ†æ
åŸºäº `infrastructure-common` å’Œ `composition` çš„å®ç°ï¼Œç³»ç»Ÿå·²å…·å¤‡ï¼š

- âœ… **ç»„ä»¶çº¦å®šè§„èŒƒ** (`ComponentConventions`) - æ”¯æŒåŸºäºå‘½åçº¦å®šçš„ç»„ä»¶å‘ç°
- âœ… **ç»„ä»¶æ‰«æå™¨** (`ComponentScannerImpl`) - æ”¯æŒ crate çº§åˆ«çš„ç»„ä»¶æ‰«æ
- âœ… **ç”Ÿå‘½å‘¨æœŸç®¡ç†** (`LifecycleManager`) - æ”¯æŒ Singletonã€Scopedã€Transient
- âœ… **å¥åº·æ£€æŸ¥é›†æˆ** (`HealthCheckable`) - è‡ªåŠ¨å¥åº·æ£€æŸ¥æ³¨å†Œ

#### æ‰©å±•ç­–ç•¥

**å¢å¼ºç»„ä»¶å‘ç°èƒ½åŠ›**
```mermaid
classDiagram
    class ExistingComponentScanner {
        <<å·²å®ç°>>
        +scan_crates() -> Vec<ComponentDescriptor>
        +discover_by_convention() -> Vec<ComponentDescriptor>
    }
    
    class EnhancedComponentDiscovery {
        <<æ‰©å±•>>
        +discover_by_attributes() -> Vec<ComponentDescriptor>
        +discover_by_trait_bounds() -> Vec<ComponentDescriptor>
        +discover_conditional_components() -> Vec<ComponentDescriptor>
    }
    
    class ComponentMetadataEnhancer {
        <<æ–°å¢>>
        +extract_documentation() -> ComponentDoc
        +analyze_dependencies() -> DependencyGraph
        +validate_component_contracts() -> ValidationResult
    }
    
    ExistingComponentScanner <|-- EnhancedComponentDiscovery
    EnhancedComponentDiscovery --> ComponentMetadataEnhancer
```

**æ‰©å±•ç°æœ‰çº¦å®šè§„èŒƒ**
```rust
// åŸºäºç°æœ‰çš„ ComponentConventionsï¼Œæ·»åŠ æ–°çš„çº¦å®šè§„åˆ™
impl ComponentConventions {
    pub fn register_ad_engine_conventions(&mut self) {
        // å¹¿å‘Šç­–ç•¥ç»„ä»¶çº¦å®š
        self.add_convention(ConventionRule::new(
            "*Strategy",
            Lifetime::Transient,
            "strategies.{component_name}"
        ).with_required_trait::<dyn AdProcessingStrategy>());
        
        // æ•°æ®æä¾›è€…çº¦å®š
        self.add_convention(ConventionRule::new(
            "*Provider", 
            Lifetime::Scoped,
            "providers.{component_name}"
        ).with_required_trait::<dyn DataProvider>());
        
        // ç¼“å­˜ç®¡ç†å™¨çº¦å®š
        self.add_convention(ConventionRule::new(
            "*CacheManager",
            Lifetime::Singleton, 
            "cache.{component_name}"
        ).with_required_trait::<dyn CacheManager>());
    }
}
```

### 2. æ‰©å±•é…ç½®ç®¡ç†èƒ½åŠ›

#### ç°æœ‰é…ç½®ç®¡ç†åˆ†æ
åŸºäº `config-abstractions` å’Œ `config-impl` çš„å®ç°ï¼š

- âœ… **å¤šæºé…ç½®æ”¯æŒ** - TOMLã€JSONã€ç¯å¢ƒå˜é‡
- âœ… **ç±»å‹å®‰å…¨ç»‘å®š** - åŸºäº serde çš„å¼ºç±»å‹é…ç½®
- âœ… **é…ç½®éªŒè¯** - `ConfigValidator` trait
- âœ… **é…ç½®ç®¡ç†å™¨** - `AdSystemConfigManager`

#### æ‰©å±•é…ç½®èƒ½åŠ›

**æ·»åŠ æ–°çš„é…ç½®æº**
```rust
// æ‰©å±•ç°æœ‰çš„ ConfigProvider trait
pub struct DatabaseConfigProvider {
    connection_pool: Arc<sqlx::PgPool>,
    table_name: String,
}

#[async_trait]
impl ConfigProvider for DatabaseConfigProvider {
    async fn get_configuration(&self, key: &str) -> Result<serde_json::Value, ConfigError> {
        let query = format!(
            "SELECT config_value FROM {} WHERE config_key = $1", 
            self.table_name
        );
        
        let row: (serde_json::Value,) = sqlx::query_as(&query)
            .bind(key)
            .fetch_one(&*self.connection_pool)
            .await
            .map_err(|e| ConfigError::ProviderError { 
                source: Box::new(e) 
            })?;
            
        Ok(row.0)
    }
    
    // ... å…¶ä»–æ–¹æ³•å®ç°
}

// æ‰©å±•ç°æœ‰çš„ InfrastructureBuilder
impl InfrastructureBuilder {
    pub fn add_database_config_source(
        mut self, 
        connection_string: String,
        table_name: String
    ) -> Result<Self, InfrastructureError> {
        let provider = DatabaseConfigProvider::new(connection_string, table_name)?;
        self.config_sources.push(Box::new(provider));
        Ok(self)
    }
}
```

**å¢å¼ºé…ç½®çƒ­é‡è½½**
```mermaid
sequenceDiagram
    participant App as åº”ç”¨ç¨‹åº
    participant Builder as InfrastructureBuilder
    participant Watcher as ConfigWatcher
    participant Manager as AdSystemConfigManager
    participant Component as ä¸šåŠ¡ç»„ä»¶
    
    App->>Builder: enable_hot_reload(true)
    Builder->>Watcher: åˆ›å»ºæ–‡ä»¶ç›‘æ§å™¨
    Watcher->>Manager: æ³¨å†Œé…ç½®å˜æ›´ç›‘å¬
    
    Note over Watcher: é…ç½®æ–‡ä»¶å˜æ›´
    Watcher->>Manager: é€šçŸ¥é…ç½®å˜æ›´
    Manager->>Manager: éªŒè¯æ–°é…ç½®
    Manager->>Component: æ¨é€é…ç½®æ›´æ–°
    Component->>Component: åº”ç”¨æ–°é…ç½®
```

### 3. æ–°å¢æ•°æ®è®¿é—®å±‚æ¶æ„

#### è®¾è®¡ç›®æ ‡
åŸºäºç°æœ‰çš„ä¾èµ–æ³¨å…¥å’Œé…ç½®ç®¡ç†åŸºç¡€è®¾æ–½ï¼Œæ–°å¢æ•°æ®è®¿é—®å±‚ï¼š

- åˆ©ç”¨ç°æœ‰çš„ `Component` trait å’Œçº¦å®šè§„èŒƒ
- é›†æˆåˆ°ç°æœ‰çš„ `AdSystemInfrastructure` ä¸­
- æ”¯æŒå¤šç§æ•°æ®åº“å’Œç¼“å­˜ç³»ç»Ÿ
- å®ç°ç¼“å­˜ä¼˜å…ˆçš„æ•°æ®è®¿é—®ç­–ç•¥

#### æ•°æ®è®¿é—®æŠ½è±¡å±‚è®¾è®¡

**æ–°å¢ crate: `data-abstractions`**
```rust
// åˆ©ç”¨ç°æœ‰çš„ Component trait
use infrastructure_common::{Component, Configurable};

#[async_trait]
pub trait Repository<T>: Component + Send + Sync {
    async fn get(&self, id: &str) -> Result<Option<T>, RepoError>;
    async fn save(&self, entity: &T) -> Result<(), RepoError>;
    async fn delete(&self, id: &str) -> Result<(), RepoError>;
    async fn find_by_spec(&self, spec: &dyn Specification<T>) -> Result<Vec<T>, RepoError>;
}

#[async_trait]
pub trait DataAccessProvider: Component + Configurable + Send + Sync {
    type Connection: Send + Sync;
    
    async fn get_connection(&self) -> Result<Self::Connection, DataError>;
    async fn execute_query(&self, query: &str) -> Result<QueryResult, DataError>;
    async fn execute_command(&self, command: &str) -> Result<CommandResult, DataError>;
}

// é›†æˆåˆ°ç°æœ‰çš„ç»„ä»¶çº¦å®šä¸­
impl ComponentConventions {
    pub fn register_data_access_conventions(&mut self) {
        self.add_convention(ConventionRule::new(
            "*Repository",
            Lifetime::Scoped,
            "data.repositories.{component_name}"
        ));
        
        self.add_convention(ConventionRule::new(
            "*Provider",
            Lifetime::Singleton,
            "data.providers.{component_name}"
        ));
    }
}
```

**é›†æˆåˆ°ç°æœ‰åŸºç¡€è®¾æ–½**
```rust
// æ‰©å±•ç°æœ‰çš„ InfrastructureBuilder
impl InfrastructureBuilder {
    pub fn add_data_access_layer(mut self) -> Self {
        // æ³¨å†Œæ•°æ®è®¿é—®ç›¸å…³çš„çº¦å®šè§„èŒƒ
        self.component_scanners.push(Box::new(
            DataAccessComponentScanner::new()
        ));
        self
    }
    
    pub fn add_database_provider<T: DataAccessProvider + 'static>(
        mut self, 
        provider: T
    ) -> Self {
        // åˆ©ç”¨ç°æœ‰çš„ç»„ä»¶æ³¨å†Œæœºåˆ¶
        self.register_component_instance(provider);
        self
    }
}
```

**æ•°æ®è®¿é—®æµç¨‹**
```mermaid
sequenceDiagram
    participant App as åº”ç”¨ç¨‹åº
    participant Infra as AdSystemInfrastructure
    participant Repo as Repository
    participant Cache as CacheProvider
    participant DB as DataAccessProvider
    
    App->>Infra: resolve::<UserRepository>()
    Infra->>Repo: è¿”å›æ³¨å†Œçš„Repository
    App->>Repo: get_user(id)
    Repo->>Cache: get(cache_key)
    alt ç¼“å­˜å‘½ä¸­
        Cache-->>Repo: Some(user)
        Repo-->>App: è¿”å›ç”¨æˆ·
    else ç¼“å­˜æœªå‘½ä¸­
        Repo->>DB: query_user(id)
        DB-->>Repo: user_data
        Repo->>Cache: set(cache_key, user)
        Repo-->>App: è¿”å›ç”¨æˆ·
    end
```

### 4. æ–°å¢åˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿ

#### è®¾è®¡ç›®æ ‡
åŸºäºç°æœ‰åŸºç¡€è®¾æ–½ï¼Œæ–°å¢ç¼“å­˜ç³»ç»Ÿï¼š

- åˆ©ç”¨ç°æœ‰çš„ç»„ä»¶å‘ç°å’Œæ³¨å†Œæœºåˆ¶
- é›†æˆåˆ°ç°æœ‰çš„é…ç½®ç®¡ç†ç³»ç»Ÿ
- æ”¯æŒå¥åº·æ£€æŸ¥å’Œç›‘æ§
- æä¾›å¤šçº§ç¼“å­˜å’Œæ™ºèƒ½ç¼“å­˜ç­–ç•¥

#### ç¼“å­˜æŠ½è±¡å±‚è®¾è®¡

**æ–°å¢ crate: `caching-abstractions`**
```rust
use infrastructure_common::{Component, Configurable, HealthCheckable};

#[async_trait]
pub trait CacheProvider: Component + Configurable + HealthCheckable + Send + Sync {
    async fn get<T>(&self, key: &str) -> Result<Option<T>, CacheError>
    where
        T: for<'de> Deserialize<'de> + Send + 'static;
        
    async fn set<T>(&self, key: &str, value: &T, ttl: Option<Duration>) -> Result<(), CacheError>
    where
        T: Serialize + Send + Sync;
        
    async fn remove(&self, key: &str) -> Result<(), CacheError>;
    async fn exists(&self, key: &str) -> Result<bool, CacheError>;
}

// åˆ©ç”¨ç°æœ‰çš„çº¦å®šè§„èŒƒ
impl ComponentConventions {
    pub fn register_cache_conventions(&mut self) {
        self.add_convention(ConventionRule::new(
            "*CacheProvider",
            Lifetime::Singleton,
            "cache.providers.{component_name}"
        ));
        
        self.add_convention(ConventionRule::new(
            "*CacheManager", 
            Lifetime::Singleton,
            "cache.managers.{component_name}"
        ));
    }
}
```

**Redisç¼“å­˜å®ç° (æ–°å¢ crate: `caching-redis`)**
```rust
use caching_abstractions::CacheProvider;
use infrastructure_common::{Component, Configurable, HealthCheckable, HealthStatus};

#[derive(Debug, Clone, Deserialize)]
pub struct RedisCacheConfig {
    pub cluster_urls: Vec<String>,
    pub connection_timeout: Duration,
    pub read_timeout: Duration,
    pub write_timeout: Duration,
}

pub struct RedisCacheProvider {
    client: redis::cluster::ClusterClient,
    config: RedisCacheConfig,
}

impl Component for RedisCacheProvider {
    fn name(&self) -> &'static str {
        "RedisCacheProvider"
    }
}

impl Configurable for RedisCacheProvider {
    type Config = RedisCacheConfig;
    
    fn configure(&mut self, config: Self::Config) -> Result<(), ConfigError> {
        self.config = config;
        // é‡æ–°åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥
        self.client = redis::cluster::ClusterClient::new(self.config.cluster_urls.clone())?;
        Ok(())
    }
    
    fn get_config_path() -> &'static str {
        "cache.providers.redis"
    }
}

#[async_trait]
impl HealthCheckable for RedisCacheProvider {
    async fn check_health(&self) -> HealthStatus {
        match self.client.get_async_connection().await {
            Ok(mut conn) => {
                match redis::cmd("PING").query_async::<_, String>(&mut conn).await {
                    Ok(_) => HealthStatus::healthy(),
                    Err(e) => HealthStatus::unhealthy(&format!("Redis PING failed: {}", e)),
                }
            }
            Err(e) => HealthStatus::unhealthy(&format!("Redis connection failed: {}", e)),
        }
    }
}

// è‡ªåŠ¨æ³¨å†Œåˆ°åŸºç¡€è®¾æ–½
#[component(singleton)]
impl RedisCacheProvider {
    pub fn new() -> Self {
        Self {
            client: redis::cluster::ClusterClient::new(vec![]).unwrap(),
            config: RedisCacheConfig::default(),
        }
    }
}
```

**é›†æˆåˆ°ç°æœ‰åŸºç¡€è®¾æ–½**
```rust
// æ‰©å±•ç°æœ‰çš„ InfrastructureBuilder
impl InfrastructureBuilder {
    pub fn add_redis_cache(mut self) -> Self {
        // åˆ©ç”¨ç°æœ‰çš„ç»„ä»¶æ‰«ææœºåˆ¶è‡ªåŠ¨å‘ç°å’Œæ³¨å†Œ
        self.scan_crate("caching-redis")
    }
    
    pub fn add_cache_layer(mut self) -> Self {
        self.scan_crate("caching-abstractions")
            .scan_crate("caching-redis")
    }
}
```

### 5. æ–°å¢å·¥ä½œæµå¼•æ“ä¸çŠ¶æ€æœº

#### è®¾è®¡ç›®æ ‡
åŸºäºç°æœ‰åŸºç¡€è®¾æ–½ï¼Œæ–°å¢å·¥ä½œæµå¼•æ“ï¼š

- åˆ©ç”¨ç°æœ‰çš„ç»„ä»¶æ³¨å†Œå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- é›†æˆåˆ°ç°æœ‰çš„é…ç½®å’Œå¥åº·æ£€æŸ¥ç³»ç»Ÿ
- æ”¯æŒäº‹ä»¶é©±åŠ¨çš„å·¥ä½œæµè§¦å‘
- æä¾›çŠ¶æ€ç®¡ç†å’Œæµç¨‹ç¼–æ’èƒ½åŠ›

#### å·¥ä½œæµæŠ½è±¡å±‚è®¾è®¡

**æ–°å¢ crate: `workflow-abstractions`**
```rust
use infrastructure_common::{Component, Configurable, HealthCheckable};

#[async_trait]
pub trait WorkflowEngine: Component + Configurable + Send + Sync {
    async fn execute_workflow(
        &self, 
        definition: &WorkflowDefinition, 
        context: &WorkflowContext
    ) -> Result<WorkflowResult, WorkflowError>;
    
    async fn pause_workflow(&self, instance_id: &str) -> Result<(), WorkflowError>;
    async fn resume_workflow(&self, instance_id: &str) -> Result<(), WorkflowError>;
    async fn cancel_workflow(&self, instance_id: &str) -> Result<(), WorkflowError>;
    async fn get_workflow_status(&self, instance_id: &str) -> Result<WorkflowStatus, WorkflowError>;
}

#[async_trait]
pub trait TaskExecutor: Component + Send + Sync {
    async fn execute(&self, context: &TaskContext) -> Result<TaskResult, TaskError>;
    fn can_execute(&self, context: &TaskContext) -> bool;
    fn get_required_permissions(&self) -> Vec<Permission>;
}

// é›†æˆåˆ°ç°æœ‰çº¦å®šè§„èŒƒ
impl ComponentConventions {
    pub fn register_workflow_conventions(&mut self) {
        self.add_convention(ConventionRule::new(
            "*WorkflowEngine",
            Lifetime::Singleton,
            "workflow.engines.{component_name}"
        ));
        
        self.add_convention(ConventionRule::new(
            "*TaskExecutor",
            Lifetime::Transient,
            "workflow.executors.{component_name}"
        ));
    }
}
```

**å·¥ä½œæµå¼•æ“å®ç° (æ–°å¢ crate: `workflow-impl`)**
```rust
use workflow_abstractions::{WorkflowEngine, TaskExecutor};
use infrastructure_common::{Component, Configurable, HealthCheckable, HealthStatus};

#[derive(Debug, Clone, Deserialize)]
pub struct WorkflowEngineConfig {
    pub max_concurrent_workflows: usize,
    pub task_timeout: Duration,
    pub retry_attempts: u32,
}

pub struct DefaultWorkflowEngine {
    config: WorkflowEngineConfig,
    task_executors: Arc<RwLock<HashMap<String, Arc<dyn TaskExecutor>>>>,
    active_workflows: Arc<RwLock<HashMap<String, WorkflowInstance>>>,
}

impl Component for DefaultWorkflowEngine {
    fn name(&self) -> &'static str {
        "DefaultWorkflowEngine"
    }
}

impl Configurable for DefaultWorkflowEngine {
    type Config = WorkflowEngineConfig;
    
    fn configure(&mut self, config: Self::Config) -> Result<(), ConfigError> {
        self.config = config;
        Ok(())
    }
    
    fn get_config_path() -> &'static str {
        "workflow.engines.default"
    }
}

#[async_trait]
impl HealthCheckable for DefaultWorkflowEngine {
    async fn check_health(&self) -> HealthStatus {
        let active_count = self.active_workflows.read().await.len();
        if active_count > self.config.max_concurrent_workflows {
            HealthStatus::degraded(&format!(
                "å·¥ä½œæµæ•°é‡è¿‡å¤š: {}/{}",
                active_count,
                self.config.max_concurrent_workflows
            ))
        } else {
            HealthStatus::healthy()
        }
    }
}

// è‡ªåŠ¨æ³¨å†Œåˆ°åŸºç¡€è®¾æ–½
#[component(singleton)]
impl DefaultWorkflowEngine {
    pub fn new() -> Self {
        Self {
            config: WorkflowEngineConfig::default(),
            task_executors: Arc::new(RwLock::new(HashMap::new())),
            active_workflows: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}
```

**é›†æˆåˆ°ç°æœ‰åŸºç¡€è®¾æ–½**
```rust
// æ‰©å±•ç°æœ‰çš„ InfrastructureBuilder
impl InfrastructureBuilder {
    pub fn add_workflow_engine(mut self) -> Self {
        self.scan_crate("workflow-abstractions")
            .scan_crate("workflow-impl")
    }
}

// åœ¨åº”ç”¨ä¸­ä½¿ç”¨
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let infrastructure = AdSystemInfrastructure::builder()
        .add_config_toml("config/app.toml")?
        .add_workflow_engine()
        .build()
        .await?;
    
    // è§£æå·¥ä½œæµå¼•æ“
    let workflow_engine = infrastructure.resolve::<dyn WorkflowEngine>().await?;
    
    // æ‰§è¡Œå·¥ä½œæµ
    let result = workflow_engine.execute_workflow(&definition, &context).await?;
    
    Ok(())
}
```

### 6. ä¼˜åŒ–ç°æœ‰é…ç½®ç®¡ç†ä¸ä¾èµ–æ³¨å…¥

#### ç°æœ‰èƒ½åŠ›æ€»ç»“
åŸºäº `crates/05-infrastructure` çš„åˆ†æï¼Œä»¥ä¸‹åŠŸèƒ½å·²ç»å®Œæ•´å®ç°ï¼š

- âœ… **ç»Ÿä¸€é…ç½®ç®¡ç†** - `AdSystemConfigManager` æ”¯æŒå¤šæºé…ç½®
- âœ… **ä¾èµ–æ³¨å…¥æ¡†æ¶** - `DiContainerImpl` æ”¯æŒå®Œæ•´çš„DIåŠŸèƒ½
- âœ… **ç»„ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†** - æ”¯æŒ Singletonã€Scopedã€Transient
- âœ… **ç»„ä»¶çº¦å®šè§„èŒƒ** - `ComponentConventions` æ”¯æŒåŸºäºçº¦å®šçš„å‘ç°
- âœ… **å¥åº·æ£€æŸ¥é›†æˆ** - `HealthCheckable` trait è‡ªåŠ¨é›†æˆ

#### ä¼˜åŒ–å»ºè®®

**1. å¢å¼ºç°æœ‰é…ç½®çƒ­é‡è½½**
```rust
// åŸºäºç°æœ‰çš„ AdSystemConfigManagerï¼Œæ·»åŠ çƒ­é‡è½½èƒ½åŠ›
impl AdSystemConfigManager {
    pub async fn enable_hot_reload(&mut self) -> Result<(), ConfigError> {
        let watcher = ConfigFileWatcher::new()?;
        
        // ç›‘æ§é…ç½®æ–‡ä»¶å˜æ›´
        for provider in &self.providers {
            if let Some(file_path) = provider.get_file_path() {
                watcher.add_watch_path(&file_path).await?;
            }
        }
        
        // å¯åŠ¨ç›‘æ§ä»»åŠ¡
        let change_receiver = watcher.get_change_receiver();
        let manager_weak = Arc::downgrade(&Arc::new(self.clone()));
        
        tokio::spawn(async move {
            while let Ok(event) = change_receiver.recv().await {
                if let Some(manager) = manager_weak.upgrade() {
                    if let Err(e) = manager.handle_config_change(event).await {
                        tracing::error!("é…ç½®çƒ­é‡è½½å¤±è´¥: {}", e);
                    }
                }
            }
        });
        
        Ok(())
    }
}
```

**2. æ‰©å±•ç°æœ‰ç»„ä»¶æ‰«æèƒ½åŠ›**
```rust
// åŸºäºç°æœ‰çš„ ComponentScannerImplï¼Œæ·»åŠ æ›´å¤šå‘ç°ç­–ç•¥
impl ComponentScannerImpl {
    pub fn with_attribute_discovery(mut self) -> Self {
        // æ·»åŠ åŸºäºå±æ€§çš„ç»„ä»¶å‘ç°
        self.add_discovery_strategy(AttributeBasedDiscovery::new());
        self
    }
    
    pub fn with_trait_discovery<T: 'static>(mut self) -> Self {
        // æ·»åŠ åŸºäº trait çš„ç»„ä»¶å‘ç°
        self.add_discovery_strategy(TraitBasedDiscovery::<T>::new());
        self
    }
    
    pub fn with_conditional_discovery(mut self) -> Self {
        // æ·»åŠ æ¡ä»¶åŒ–ç»„ä»¶å‘ç°
        self.add_discovery_strategy(ConditionalDiscovery::new());
        self
    }
}
```

**3. å¢å¼ºç°æœ‰åŸºç¡€è®¾æ–½æ„å»ºå™¨**
```rust
// åŸºäºç°æœ‰çš„ InfrastructureBuilderï¼Œæ·»åŠ æ›´å¤šä¾¿åˆ©æ–¹æ³•
impl InfrastructureBuilder {
    pub fn auto_configure_for_environment(mut self, env: Environment) -> Self {
        match env {
            Environment::Development => {
                self.add_config_toml("config/dev.toml")
                    .unwrap()
                    .enable_hot_reload(true)
                    .enable_debug_logging()
            }
            Environment::Production => {
                self.add_config_toml("config/prod.toml")
                    .unwrap()
                    .add_config_env_vars("ADSP_")
                    .unwrap()
                    .enable_performance_monitoring()
            }
            Environment::Testing => {
                self.add_config_toml("config/test.toml")
                    .unwrap()
                    .enable_test_mode()
            }
        }
    }
    
    pub fn add_all_infrastructure_layers(mut self) -> Self {
        self.add_data_access_layer()
            .add_cache_layer()
            .add_workflow_engine()
            .add_monitoring_layer()
            .add_security_layer()
    }
}
```

**4. å®Œæ•´çš„ä½¿ç”¨ç¤ºä¾‹**
```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ©ç”¨ç°æœ‰åŸºç¡€è®¾æ–½ï¼Œæ·»åŠ æ–°çš„æ‰©å±•å±‚
    let infrastructure = AdSystemInfrastructure::builder()
        .auto_configure_for_environment(Environment::Development)
        .add_all_infrastructure_layers()
        .scan_crate("ad-engine")?
        .scan_crate("user-targeting")?
        .scan_crate("bid-processing")?
        .build()
        .await?;
    
    // å¯åŠ¨åŸºç¡€è®¾æ–½
    infrastructure.start().await?;
    
    // ä½¿ç”¨ç°æœ‰çš„è§£æèƒ½åŠ›
    let user_service = infrastructure.resolve::<UserService>().await?;
    let cache_provider = infrastructure.resolve::<dyn CacheProvider>().await?;
    let workflow_engine = infrastructure.resolve::<dyn WorkflowEngine>().await?;
    
    // æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€
    let health_status = infrastructure.get_overall_health().await;
    println!("ç³»ç»Ÿå¥åº·çŠ¶æ€: {:?}", health_status);
    
    Ok(())
}
```

## åŸºäºç°æœ‰åŸºç¡€è®¾æ–½çš„æŠ€æœ¯å®ç°

### ç°æœ‰æŠ€æœ¯æ ˆåˆ†æ

#### å·²å®ç°çš„æ ¸å¿ƒæŠ€æœ¯
åŸºäº `crates/05-infrastructure` çš„åˆ†æï¼š

- âœ… **å¼‚æ­¥è¿è¡Œæ—¶**: åŸºäº Tokio çš„å¼‚æ­¥åŸºç¡€è®¾æ–½
- âœ… **é…ç½®ç®¡ç†**: åŸºäº serde çš„ç±»å‹å®‰å…¨é…ç½®ç»‘å®š
- âœ… **ä¾èµ–æ³¨å…¥**: å®Œæ•´çš„ DI å®¹å™¨å®ç°
- âœ… **ç»„ä»¶å‘ç°**: åŸºäºçº¦å®šçš„ç»„ä»¶æ‰«ææœºåˆ¶
- âœ… **å¥åº·æ£€æŸ¥**: é›†æˆçš„å¥åº·æ£€æŸ¥æ¡†æ¶

#### éœ€è¦æ–°å¢çš„æŠ€æœ¯æ ˆ

**æ•°æ®åº“ä¸ORMå±‚**
```rust
// æ–°å¢ crate: data-abstractions
[dependencies]
sea-orm = { version = "0.12", features = ["sqlx-postgres", "sqlx-mysql", "runtime-tokio-rustls"] }
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "mysql"] }

// é›†æˆåˆ°ç°æœ‰åŸºç¡€è®¾æ–½
impl InfrastructureBuilder {
    pub fn add_sea_orm_support(mut self, database_url: String) -> Result<Self, InfrastructureError> {
        let db_provider = SeaOrmDataProvider::new(database_url)?;
        self.register_component_instance(db_provider);
        Ok(self)
    }
}
```

**ç¼“å­˜ä¸å­˜å‚¨å±‚**
```rust
// æ–°å¢ crate: caching-redis
[dependencies]
redis = { version = "0.24", features = ["cluster", "tokio-comp"] }
tokio = { version = "1.0", features = ["full"] }

// é›†æˆåˆ°ç°æœ‰åŸºç¡€è®¾æ–½
impl InfrastructureBuilder {
    pub fn add_redis_cluster(mut self, cluster_urls: Vec<String>) -> Result<Self, InfrastructureError> {
        let redis_provider = RedisCacheProvider::new(cluster_urls)?;
        self.register_component_instance(redis_provider);
        Ok(self)
    }
}
```

### æ–°å¢ç›‘æ§ä¸å¯è§‚æµ‹æ€§

#### ç›‘æ§æŠ½è±¡å±‚è®¾è®¡

**æ–°å¢ crate: `monitoring`**
```rust
use infrastructure_common::{Component, Configurable, HealthCheckable};

#[async_trait]
pub trait MetricsCollector: Component + Send + Sync {
    async fn record_counter(&self, name: &str, value: u64, tags: &[Tag]);
    async fn record_histogram(&self, name: &str, value: f64, tags: &[Tag]);
    async fn record_gauge(&self, name: &str, value: f64, tags: &[Tag]);
    async fn flush(&self) -> Result<(), MetricsError>;
}

// åˆ©ç”¨ç°æœ‰çš„ç»„ä»¶çº¦å®š
impl ComponentConventions {
    pub fn register_monitoring_conventions(&mut self) {
        self.add_convention(ConventionRule::new(
            "*MetricsCollector",
            Lifetime::Singleton,
            "monitoring.metrics.{component_name}"
        ));
        
        self.add_convention(ConventionRule::new(
            "*TracingCollector",
            Lifetime::Singleton,
            "monitoring.tracing.{component_name}"
        ));
    }
}
```

**Prometheusé›†æˆå®ç°**
```rust
use monitoring::{MetricsCollector, Tag};
use prometheus::{Counter, Histogram, Gauge, Registry};

pub struct PrometheusMetricsCollector {
    registry: Registry,
    counters: Arc<RwLock<HashMap<String, Counter>>>,
    histograms: Arc<RwLock<HashMap<String, Histogram>>>,
    gauges: Arc<RwLock<HashMap<String, Gauge>>>,
}

impl Component for PrometheusMetricsCollector {
    fn name(&self) -> &'static str {
        "PrometheusMetricsCollector"
    }
}

#[async_trait]
impl MetricsCollector for PrometheusMetricsCollector {
    async fn record_counter(&self, name: &str, value: u64, tags: &[Tag]) {
        let mut counters = self.counters.write().await;
        let counter = counters.entry(name.to_string())
            .or_insert_with(|| {
                let counter = Counter::new(name, "Counter metric").unwrap();
                self.registry.register(Box::new(counter.clone())).unwrap();
                counter
            });
        counter.inc_by(value as f64);
    }
    
    // ... å…¶ä»–æ–¹æ³•å®ç°
}

// è‡ªåŠ¨æ³¨å†Œåˆ°åŸºç¡€è®¾æ–½
#[component(singleton)]
impl PrometheusMetricsCollector {
    pub fn new() -> Self {
        Self {
            registry: Registry::new(),
            counters: Arc::new(RwLock::new(HashMap::new())),
            histograms: Arc::new(RwLock::new(HashMap::new())),
            gauges: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}
```

#### é›†æˆåˆ°ç°æœ‰åŸºç¡€è®¾æ–½

**æ‰©å±•ç°æœ‰çš„å¥åº·æ£€æŸ¥ç³»ç»Ÿ**
```rust
// åŸºäºç°æœ‰çš„ HealthCheckable traitï¼Œæ·»åŠ ç›‘æ§é›†æˆ
impl AdSystemInfrastructure {
    pub async fn get_detailed_health_report(&self) -> DetailedHealthReport {
        let health_results = self.check_health().await;
        let metrics = self.collect_health_metrics().await;
        
        DetailedHealthReport {
            overall_status: self.get_overall_health().await,
            component_health: health_results,
            performance_metrics: metrics,
            timestamp: chrono::Utc::now(),
        }
    }
    
    async fn collect_health_metrics(&self) -> HealthMetrics {
        let metrics_collector = self.resolve::<dyn MetricsCollector>().await
            .unwrap_or_else(|_| Arc::new(NoOpMetricsCollector));
            
        HealthMetrics {
            response_time: metrics_collector.get_histogram("health_check_duration").await,
            error_rate: metrics_collector.get_counter("health_check_errors").await,
            component_count: self.get_registered_components().await.len(),
        }
    }
}
```

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### åŸºäºç°æœ‰æ¶æ„çš„ä¼˜åŒ–

**1. ç»„ä»¶è§£æç¼“å­˜**
```rust
// ä¼˜åŒ–ç°æœ‰çš„ DiContainerImpl
impl DiContainerImpl {
    pub fn with_resolution_cache(mut self) -> Self {
        self.enable_resolution_cache = true;
        self
    }
    
    async fn resolve_with_cache<T: Component + 'static>(&self) -> Result<Arc<T>, DependencyError> {
        let type_id = TypeId::of::<T>();
        
        // æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.resolution_cache.get(&type_id).await {
            if let Ok(component) = cached.downcast::<T>() {
                return Ok(component);
            }
        }
        
        // è§£æå¹¶ç¼“å­˜
        let component = self.resolve_uncached::<T>().await?;
        self.resolution_cache.insert(type_id, component.clone()).await;
        Ok(component)
    }
}
```

**2. é…ç½®åŠ è½½ä¼˜åŒ–**
```rust
// ä¼˜åŒ–ç°æœ‰çš„ AdSystemConfigManager
impl AdSystemConfigManager {
    pub fn with_config_cache(mut self) -> Self {
        self.cache_enabled = true;
        self
    }
    
    pub async fn preload_configurations(&mut self) -> Result<(), ConfigError> {
        // é¢„åŠ è½½å¸¸ç”¨é…ç½®
        let common_configs = vec![
            "database",
            "cache.redis", 
            "monitoring.metrics",
            "workflow.engines.default"
        ];
        
        for config_path in common_configs {
            let _ = self.get_configuration(config_path).await;
        }
        
        Ok(())
    }
}
```

## éƒ¨ç½²æ¶æ„

### å®¹å™¨åŒ–éƒ¨ç½²

#### Dockeré…ç½®
```dockerfile
FROM rust:1.75-slim as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY crates/ crates/

RUN cargo build --release --bin infrastructure-demo

FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/infrastructure-demo /usr/local/bin/

COPY config/ /app/config/

WORKDIR /app

EXPOSE 8080

CMD ["infrastructure-demo"]
```

#### Kuberneteséƒ¨ç½²
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: core-infrastructure
spec:
  replicas: 3
  selector:
    matchLabels:
      app: core-infrastructure
  template:
    metadata:
      labels:
        app: core-infrastructure
    spec:
      containers:
      - name: infrastructure
        image: lorn-adsp/core-infrastructure:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

### å¤šäº‘æ”¯æŒ

#### äº‘å¹³å°æŠ½è±¡
```mermaid
classDiagram
    class CloudProvider {
        <<trait>>
        +platform_name() -> &str
        +create_database_instance(config: &DatabaseConfig) -> Result<DatabaseInstance>
        +create_cache_instance(config: &CacheConfig) -> Result<CacheInstance>
        +create_storage_bucket(config: &StorageConfig) -> Result<StorageBucket>
    }
    
    class AlibabaCloudProvider {
        +platform_name() -> &str = "AlibabaCloud"
        +create_database_instance(config: &DatabaseConfig) -> Result<DatabaseInstance>
        +create_cache_instance(config: &CacheConfig) -> Result<CacheInstance>
    }
    
    class AzureCloudProvider {
        +platform_name() -> &str = "Azure"
        +create_database_instance(config: &DatabaseConfig) -> Result<DatabaseInstance>
        +create_cache_instance(config: &CacheConfig) -> Result<CacheInstance>
    }
    
    class AwsCloudProvider {
        +platform_name() -> &str = "AWS"
        +create_database_instance(config: &DatabaseConfig) -> Result<DatabaseInstance>
        +create_cache_instance(config: &CacheConfig) -> Result<CacheInstance>
    }
    
    CloudProvider <|.. AlibabaCloudProvider
    CloudProvider <|.. AzureCloudProvider
    CloudProvider <|.. AwsCloudProvider
```

## å®‰å…¨è®¾è®¡

### æ•°æ®å®‰å…¨

#### åŠ å¯†å­˜å‚¨
- **ä¼ è¾“åŠ å¯†**: HTTPS/TLSä¿æŠ¤æ•°æ®ä¼ è¾“
- **å­˜å‚¨åŠ å¯†**: æ•°æ®åº“é€æ˜æ•°æ®åŠ å¯†(TDE)
- **å­—æ®µåŠ å¯†**: æ•æ„Ÿå­—æ®µåº”ç”¨å±‚åŠ å¯†
- **å¯†é’¥ç®¡ç†**: ç»Ÿä¸€å¯†é’¥ç®¡ç†æœåŠ¡

#### è®¿é—®æ§åˆ¶
- **è®¤è¯**: JWTä»¤ç‰Œè®¤è¯
- **æˆæƒ**: åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)
- **å®¡è®¡**: å®Œæ•´çš„è®¿é—®å®¡è®¡æ—¥å¿—
- **æƒé™**: APIçº§åˆ«çš„ç»†ç²’åº¦æƒé™æ§åˆ¶

### ç½‘ç»œå®‰å…¨

#### å®‰å…¨é˜²æŠ¤
- **é˜²ç«å¢™**: ç½‘ç»œå±‚è®¿é—®æ§åˆ¶
- **WAF**: Webåº”ç”¨é˜²ç«å¢™
- **DDoSé˜²æŠ¤**: åˆ†å¸ƒå¼æ‹’ç»æœåŠ¡æ”»å‡»é˜²æŠ¤
- **å…¥ä¾µæ£€æµ‹**: å®æ—¶å…¥ä¾µæ£€æµ‹å’Œå“åº”

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

#### æµ‹è¯•è¦†ç›–
- **ç»„ä»¶æµ‹è¯•**: å„åŸºç¡€è®¾æ–½ç»„ä»¶çš„å•å…ƒæµ‹è¯•
- **é›†æˆæµ‹è¯•**: ç»„ä»¶é—´åä½œçš„é›†æˆæµ‹è¯•
- **æ€§èƒ½æµ‹è¯•**: å…³é”®è·¯å¾„çš„æ€§èƒ½åŸºå‡†æµ‹è¯•
- **å®‰å…¨æµ‹è¯•**: å®‰å…¨æ¼æ´å’Œæƒé™æ§åˆ¶æµ‹è¯•

#### æµ‹è¯•å·¥å…·
- **Rustå†…ç½®æµ‹è¯•**: å•å…ƒæµ‹è¯•æ¡†æ¶
- **Mockall**: Mockæ¡†æ¶
- **Testcontainers-rs**: å®¹å™¨åŒ–æµ‹è¯•ç¯å¢ƒ
- **Criterion**: æ€§èƒ½åŸºå‡†æµ‹è¯•

### é›†æˆæµ‹è¯•

#### æµ‹è¯•åœºæ™¯
- å®Œæ•´åŸºç¡€è®¾æ–½å¯åŠ¨æµ‹è¯•
- é…ç½®çƒ­é‡è½½æµ‹è¯•
- æ•°æ®åº“è¿æ¥æ± æµ‹è¯•
- ç¼“å­˜ä¸€è‡´æ€§æµ‹è¯•
- å·¥ä½œæµæ‰§è¡Œæµ‹è¯•

## è¿ç»´ç›‘æ§

### ç›‘æ§ä½“ç³»

#### ç›‘æ§å±‚æ¬¡
- **åŸºç¡€è®¾æ–½ç›‘æ§**: æœåŠ¡å™¨ã€ç½‘ç»œã€å­˜å‚¨
- **åº”ç”¨ç›‘æ§**: åº”ç”¨æ€§èƒ½ã€é”™è¯¯ç‡ã€å“åº”æ—¶é—´
- **ä¸šåŠ¡ç›‘æ§**: ä¸šåŠ¡æŒ‡æ ‡ã€ç”¨æˆ·è¡Œä¸ºã€è½¬åŒ–ç‡
- **å®‰å…¨ç›‘æ§**: å®‰å…¨äº‹ä»¶ã€å¼‚å¸¸è®¿é—®ã€å¨èƒæ£€æµ‹

#### å‘Šè­¦æœºåˆ¶
- **é˜ˆå€¼å‘Šè­¦**: åŸºäºæŒ‡æ ‡é˜ˆå€¼çš„è‡ªåŠ¨å‘Šè­¦
- **è¶‹åŠ¿å‘Šè­¦**: åŸºäºè¶‹åŠ¿åˆ†æçš„é¢„æµ‹å‘Šè­¦
- **å¼‚å¸¸å‘Šè­¦**: åŸºäºæœºå™¨å­¦ä¹ çš„å¼‚å¸¸æ£€æµ‹å‘Šè­¦
- **ä¸šåŠ¡å‘Šè­¦**: åŸºäºä¸šåŠ¡è§„åˆ™çš„å‘Šè­¦

### æ—¥å¿—ç®¡ç†

#### æ—¥å¿—åˆ†ç±»
- **åº”ç”¨æ—¥å¿—**: åº”ç”¨ç¨‹åºè¿è¡Œæ—¥å¿—
- **è®¿é—®æ—¥å¿—**: APIè®¿é—®å’Œç”¨æˆ·è¡Œä¸ºæ—¥å¿—
- **é”™è¯¯æ—¥å¿—**: ç³»ç»Ÿé”™è¯¯å’Œå¼‚å¸¸æ—¥å¿—
- **å®¡è®¡æ—¥å¿—**: å®‰å…¨å’Œåˆè§„å®¡è®¡æ—¥å¿—

#### æ—¥å¿—å¤„ç†
- **ç»“æ„åŒ–æ—¥å¿—**: ä½¿ç”¨tracingè¿›è¡Œç»“æ„åŒ–æ—¥å¿—è®°å½•
- **æ—¥å¿—èšåˆ**: é›†ä¸­æ”¶é›†å’Œå­˜å‚¨æ—¥å¿—
- **æ—¥å¿—åˆ†æ**: å®æ—¶æ—¥å¿—åˆ†æå’Œæœç´¢
- **æ—¥å¿—å½’æ¡£**: é•¿æœŸæ—¥å¿—å­˜å‚¨å’Œå½’æ¡£

## æ€»ç»“

æœ¬è®¾è®¡æ–‡æ¡£åŸºäºå·²æœ‰çš„ `crates/05-infrastructure` åŸºç¡€è®¾æ–½ï¼Œé‡ç‚¹å…³æ³¨æ‰©å±•å’Œä¼˜åŒ–ç°æœ‰æ¶æ„ï¼Œé¿å…é‡å¤é€ è½®å­ã€‚é€šè¿‡å……åˆ†åˆ©ç”¨å·²å®ç°çš„é…ç½®ç®¡ç†ã€ä¾èµ–æ³¨å…¥ã€ç»„ä»¶å‘ç°ç­‰æ ¸å¿ƒåŠŸèƒ½ï¼Œä¸ºLorn.ADSPå¹¿å‘ŠæŠ•æ”¾ç³»ç»Ÿæä¾›å®Œæ•´çš„æŠ€æœ¯åº•åº§ã€‚

### ç°æœ‰åŸºç¡€è®¾æ–½ä¼˜åŠ¿

1. **å®Œæ•´çš„DIæ¡†æ¶**: `DiContainerImpl` æä¾›äº†å®Œæ•´çš„ä¾èµ–æ³¨å…¥èƒ½åŠ›
2. **çµæ´»çš„é…ç½®ç®¡ç†**: `AdSystemConfigManager` æ”¯æŒå¤šæºé…ç½®å’Œç±»å‹å®‰å…¨ç»‘å®š
3. **æ™ºèƒ½ç»„ä»¶å‘ç°**: `ComponentScannerImpl` åŸºäºçº¦å®šçš„è‡ªåŠ¨åŒ–ç»„ä»¶å‘ç°
4. **å¥åº·æ£€æŸ¥é›†æˆ**: `HealthCheckable` trait æä¾›ç»Ÿä¸€çš„å¥åº·æ£€æŸ¥æœºåˆ¶
5. **åŸºç¡€è®¾æ–½ç»„åˆ**: `InfrastructureBuilder` æä¾›ä¼˜é›…çš„æ„å»ºå™¨æ¨¡å¼

### æ‰©å±•ç­–ç•¥

#### 1. åŸºäºç°æœ‰åŸºç¡€è®¾æ–½çš„æ‰©å±•
- âœ… **åˆ©ç”¨ç°æœ‰ç»„ä»¶çº¦å®š** - æ‰©å±• `ComponentConventions` æ”¯æŒæ–°çš„ç»„ä»¶ç±»å‹
- âœ… **é›†æˆç°æœ‰é…ç½®ç³»ç»Ÿ** - æ–°ç»„ä»¶è‡ªåŠ¨é›†æˆåˆ° `AdSystemConfigManager`
- âœ… **å¤ç”¨ç°æœ‰å¥åº·æ£€æŸ¥** - æ–°ç»„ä»¶è‡ªåŠ¨æ”¯æŒ `HealthCheckable` trait
- âœ… **åˆ©ç”¨ç°æœ‰æ„å»ºå™¨** - é€šè¿‡ `InfrastructureBuilder` ç»Ÿä¸€ç®¡ç†

#### 2. æ–°å¢æ ¸å¿ƒèƒ½åŠ›
- ğŸ†• **æ•°æ®è®¿é—®å±‚** (`data-abstractions` + å®ç°)
- ğŸ†• **åˆ†å¸ƒå¼ç¼“å­˜** (`caching-abstractions` + `caching-redis`)
- ğŸ†• **å·¥ä½œæµå¼•æ“** (`workflow-abstractions` + `workflow-impl`)
- ğŸ†• **ç›‘æ§ç³»ç»Ÿ** (`monitoring` + Prometheusé›†æˆ)
- ğŸ†• **å®‰å…¨ç»„ä»¶** (`security` + è®¤è¯æˆæƒ)

### å®æ–½è·¯å¾„

#### é˜¶æ®µ1: æ‰©å±•ç°æœ‰åŸºç¡€è®¾æ–½
```rust
// 1. æ‰©å±•ç»„ä»¶çº¦å®šè§„èŒƒ
impl ComponentConventions {
    pub fn register_all_ad_engine_conventions(&mut self) {
        self.register_ad_engine_conventions();
        self.register_data_access_conventions();
        self.register_cache_conventions();
        self.register_workflow_conventions();
        self.register_monitoring_conventions();
    }
}

// 2. å¢å¼ºåŸºç¡€è®¾æ–½æ„å»ºå™¨
impl InfrastructureBuilder {
    pub fn add_complete_ad_infrastructure(mut self) -> Self {
        self.add_data_access_layer()
            .add_cache_layer()
            .add_workflow_engine()
            .add_monitoring_layer()
            .add_security_layer()
    }
}
```

#### é˜¶æ®µ2: å®ç°æ–°å¢ç»„ä»¶
- å®ç°æ•°æ®è®¿é—®æŠ½è±¡å±‚å’Œå…·ä½“æä¾›è€…
- å®ç°Redisç¼“å­˜æä¾›è€…å’Œå¤šçº§ç¼“å­˜ç­–ç•¥
- å®ç°å·¥ä½œæµå¼•æ“å’ŒçŠ¶æ€æœº
- å®ç°Prometheusç›‘æ§é›†æˆ
- å®ç°JWTè®¤è¯å’ŒRBACæˆæƒ

#### é˜¶æ®µ3: é›†æˆå’Œä¼˜åŒ–
- æ€§èƒ½ä¼˜åŒ–ï¼šç»„ä»¶è§£æç¼“å­˜ã€é…ç½®é¢„åŠ è½½
- ç›‘æ§é›†æˆï¼šè¯¦ç»†çš„å¥åº·æ£€æŸ¥æŠ¥å‘Šã€æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- æµ‹è¯•å®Œå–„ï¼šå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•
- æ–‡æ¡£å®Œå–„ï¼šAPIæ–‡æ¡£ã€ä½¿ç”¨æŒ‡å—ã€æœ€ä½³å®è·µ

### æ¶æ„ä¼˜åŠ¿

1. **é¿å…é‡å¤é€ è½®å­**: å……åˆ†åˆ©ç”¨å·²æœ‰çš„æˆç†ŸåŸºç¡€è®¾æ–½
2. **æ¸è¿›å¼æ‰©å±•**: åŸºäºç°æœ‰æ¶æ„é€æ­¥æ·»åŠ æ–°èƒ½åŠ›
3. **ä¸€è‡´æ€§ä¿è¯**: æ–°ç»„ä»¶éµå¾ªç°æœ‰çš„çº¦å®šå’Œæ¨¡å¼
4. **å‘åå…¼å®¹**: æ‰©å±•ä¸å½±å“ç°æœ‰åŠŸèƒ½çš„ä½¿ç”¨
5. **ç»Ÿä¸€ç®¡ç†**: é€šè¿‡ç°æœ‰çš„æ„å»ºå™¨ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç»„ä»¶

### æŠ€æœ¯åˆ›æ–°

1. **åŸºäºçº¦å®šçš„æ‰©å±•**: æ–°ç»„ä»¶è‡ªåŠ¨é›†æˆåˆ°ç°æœ‰çº¦å®šè§„èŒƒä¸­
2. **ç»„åˆå¼æ¶æ„**: é€šè¿‡ç»„åˆç°æœ‰ç»„ä»¶å®ç°å¤æ‚åŠŸèƒ½
3. **ç±»å‹å®‰å…¨æ‰©å±•**: åˆ©ç”¨Rustç±»å‹ç³»ç»Ÿä¿è¯æ‰©å±•çš„æ­£ç¡®æ€§
4. **å¼‚æ­¥ä¼˜å…ˆè®¾è®¡**: æ‰€æœ‰æ–°ç»„ä»¶éƒ½åŸºäºå¼‚æ­¥æ¨¡å¼è®¾è®¡
5. **å¯è§‚æµ‹æ€§å†…ç½®**: ç›‘æ§å’Œå¥åº·æ£€æŸ¥èƒ½åŠ›å†…ç½®åˆ°æ¯ä¸ªç»„ä»¶ä¸­

é€šè¿‡è¿™ç§åŸºäºç°æœ‰åŸºç¡€è®¾æ–½çš„æ‰©å±•ç­–ç•¥ï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿæ„å»ºå‡ºå®Œæ•´ã€ç¨³å®šã€é«˜æ€§èƒ½çš„å¹¿å‘ŠæŠ•æ”¾ç³»ç»ŸæŠ€æœ¯åº•åº§ï¼ŒåŒæ—¶ä¿æŒä»£ç çš„ç®€æ´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚